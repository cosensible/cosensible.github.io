<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|consolas:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="redis,">








  <link rel="shortcut icon" type="image/x-icon" href="/images/logo.png?v=5.1.2">






<meta name="description" content="[TOC] Redis 设计与实现第1章：概览第一部分：数据结构与对象  redis数据库里面的每个键值对都由对象组成，其中：  键总是一个字符串对象 值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象   第二部分：单机数据库的实现  第9章：数据库。介绍数据库的实现原理，说明了：  服务器保存键值对的方法 服务器保存键值对过期时间的方法 服务器自动删除过期键值对的方法  第10章：">
<meta name="keywords" content="redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis设计与实现">
<meta property="og:url" content="https://cosensible.github.io/2019/01/25/Redis设计与实现/index.html">
<meta property="og:site_name" content="IamGroot">
<meta property="og:description" content="[TOC] Redis 设计与实现第1章：概览第一部分：数据结构与对象  redis数据库里面的每个键值对都由对象组成，其中：  键总是一个字符串对象 值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象   第二部分：单机数据库的实现  第9章：数据库。介绍数据库的实现原理，说明了：  服务器保存键值对的方法 服务器保存键值对过期时间的方法 服务器自动删除过期键值对的方法  第10章：">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-08-24T09:32:36.887Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis设计与实现">
<meta name="twitter:description" content="[TOC] Redis 设计与实现第1章：概览第一部分：数据结构与对象  redis数据库里面的每个键值对都由对象组成，其中：  键总是一个字符串对象 值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象   第二部分：单机数据库的实现  第9章：数据库。介绍数据库的实现原理，说明了：  服务器保存键值对的方法 服务器保存键值对过期时间的方法 服务器自动删除过期键值对的方法  第10章：">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://cosensible.github.io/2019/01/25/Redis设计与实现/">





  <title>Redis设计与实现 | IamGroot</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">IamGroot</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Blog of Chungen lchungen@qq.com</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://cosensible.github.io/2019/01/25/Redis设计与实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chungen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="http://chungen.coding.me/pics/favicon.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IamGroot">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis设计与实现</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T00:00:00+08:00">
                2019-01-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/" itemprop="url" rel="index">
                    <span itemprop="name">笔记</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/笔记/后台/" itemprop="url" rel="index">
                    <span itemprop="name">后台</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>次
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<h1 id="Redis-设计与实现"><a href="#Redis-设计与实现" class="headerlink" title="Redis 设计与实现"></a>Redis 设计与实现</h1><h2 id="第1章：概览"><a href="#第1章：概览" class="headerlink" title="第1章：概览"></a>第1章：概览</h2><p><strong>第一部分：数据结构与对象</strong></p>
<blockquote>
<p>redis数据库里面的每个键值对都由对象组成，其中：</p>
<ol>
<li>键总是一个字符串对象</li>
<li>值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象</li>
</ol>
</blockquote>
<p><strong>第二部分：单机数据库的实现</strong></p>
<blockquote>
<p><strong>第9章：数据库。</strong>介绍数据库的实现原理，说明了：</p>
<ul>
<li>服务器保存键值对的方法</li>
<li>服务器保存键值对过期时间的方法</li>
<li>服务器自动删除过期键值对的方法</li>
</ul>
<p><strong>第10章：RDB持久化和第11章：AOF持久化。</strong>分别介绍Redis的两种持久化方式，说明了：</p>
<ul>
<li>服务器根据数据库生成持久化文件的方法，服务器根据持久化文件还原数据库的方法</li>
<li>BGSAVE命令和BGREWRITEAOF命令的实现原理</li>
</ul>
<p><strong>第12章：事件。</strong>介绍文件事件和时间事件</p>
<ul>
<li>文件事件：用于应答（accept）客户端的连接请求，接收客户端的命令请求，向客户端返回命令回复</li>
<li>时间事件：执行redis.c/serverCron函数，该函数保持Redis服务器正常运行，触发定时操作</li>
</ul>
<p><strong>第13章：客户端。</strong>介绍服务器维护和管理客户端状态的方法，客户端状态的属性，客户端的输入和输出缓冲区，服务器创建和销毁客户端状态的条件</p>
<p><strong>第14章：服务器。</strong>介绍单机服务器的运作机制，服务器处理命令请求的步骤，serverCron函数，服务器初始化过程</p>
</blockquote>
<p><strong>第三部分：多机数据库的实现</strong></p>
<blockquote>
<p><strong>第15章：复制。</strong>介绍Redis主从复制</p>
<p><strong>第16章：Sentinel。</strong>说明Sentinel监视服务器的方法，判断服务器是否下线的方法，对下线服务器进行故障转移的方法。</p>
<p><strong>第17章：集群。</strong>说明节点的构建方法，节点处理命令请求的方法，转发错误的实现，各节点通信的方法</p>
</blockquote>
<p><strong>第四部分：独立功能的实现</strong></p>
<blockquote>
<p><strong>第18章：发布与订阅。</strong>PUBLISH、SUBSCRIBE、PUBSUB等命令</p>
<p><strong>第19章：事务。</strong>MULTI、EXEC、WATCH等命令，说明Redis的事务对ACID性质的支持程度</p>
<p><strong>第20章：Lua脚本。</strong>EVAL、EVALSHA、SCRIPT LOAD等命令，解释Redis服务器如何执行和管理用户传入的Lua脚本，服务器构建Lua环境的过程，主从服务器之间复制Lua脚本的方法</p>
<p><strong>第21章：排序。</strong>SORT命令和命令选项（DESC、ALPHA、GET）以及不同选项执行的顺序</p>
<p><strong>第22章：二进制位数组。</strong>GETBIT、SETBIT、BITCOUNT、BITOP命令</p>
<p><strong>第23章：慢查询日志。</strong>SLOWLOG GET、SLOWLOG LEN、SLOWLOG RESET命令</p>
<p><strong>第24章：监视器。</strong>如何将客户端变为监视器（monitor），服务器如何向监视器发送命令信息</p>
</blockquote>
<h1 id="第一部分：数据结构与对象"><a href="#第一部分：数据结构与对象" class="headerlink" title="第一部分：数据结构与对象"></a>第一部分：数据结构与对象</h1><h2 id="第2章：简单动态字符串（SDS）"><a href="#第2章：简单动态字符串（SDS）" class="headerlink" title="第2章：简单动态字符串（SDS）"></a>第2章：简单动态字符串（SDS）</h2><p>Redis没有直接使用C字符串，在Redis里C字符串只会作为字符串字面量，用在无须修改字符串值的地方。当Redis需要一个可以被修改的字符串值时会使用SDS。SDS不仅可以用来保存字符串值，还能被用作缓冲区：AOF缓冲区、客户端状态中的输入缓冲区。</p>
<h3 id="2-1：SDS的定义"><a href="#2-1：SDS的定义" class="headerlink" title="2.1：SDS的定义"></a>2.1：SDS的定义</h3><p>每个sds.h/sdshdr结构表示一个SDS值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SDS和C字符串一样，以空字符结尾。保存空字符的1字节不算在len属性里，SDS自动为空字符分配额外的1字节且将空字符添加到字符串末尾。所以这个空字符对用户完全透明。以空字符结尾的好处是SDS可以重用C字符串函数库里面的一部分函数。</p>
<h3 id="2-2：SDS与C字符串的区别"><a href="#2-2：SDS与C字符串的区别" class="headerlink" title="2.2：SDS与C字符串的区别"></a>2.2：SDS与C字符串的区别</h3><h4 id="2-2-1：常数复杂度获取字符串长度"><a href="#2-2-1：常数复杂度获取字符串长度" class="headerlink" title="2.2.1：常数复杂度获取字符串长度"></a>2.2.1：常数复杂度获取字符串长度</h4><p>C字符串不记录自身的长度信息，所以为获取其长度需要遍历一遍。</p>
<p>获取一个SDS的长度只要常数时间，设置和更新SDS长度的工作由SDS的API在执行时自动完成。</p>
<h4 id="2-2-2：杜绝缓冲区溢出"><a href="#2-2-2：杜绝缓冲区溢出" class="headerlink" title="2.2.2：杜绝缓冲区溢出"></a>2.2.2：杜绝缓冲区溢出</h4><p>C字符串假定用户已经分配足够多的内存，若该假定不成立，就会产生缓冲区溢出。</p>
<p>当SDS API需要修改SDS时，API会先检查SDS的空间是否满足，若不满足，API会自动扩展空间，然后执行修改。无须手动修改SDS的空间大小。</p>
<h4 id="2-2-3：减少修改字符串带来的内存重分配次数"><a href="#2-2-3：减少修改字符串带来的内存重分配次数" class="headerlink" title="2.2.3：减少修改字符串带来的内存重分配次数"></a>2.2.3：减少修改字符串带来的内存重分配次数</h4><p>每次增长或缩短一个C字符串，程序都要对其数组进行一次内存重分配。</p>
<p>SDS通过未使用空间实现了空间预分配和惰性空间释放两种优化策略。</p>
<p><strong>空间预分配</strong>：当需要对SDS进行空间扩展时，程序不仅分配必须的空间，而且还会分配额外的未使用空间。额外空间数量由以下公式决定：</p>
<ul>
<li>若SDS的长度在修改后小于1MB，分配len大小的未使用空间，此时len=free。否则，分配1MB大小。</li>
</ul>
<p><strong>惰性空间释放</strong>：当SDS的API需要缩短字符串时，程序不立即释放其空间，而是使用free属性记录字节数量，等到将来使用。</p>
<p>此外，SDS提供了API让我们在需要时真正地释放SDS的未使用空间。</p>
<h4 id="2-2-4：二进制安全"><a href="#2-2-4：二进制安全" class="headerlink" title="2.2.4：二进制安全"></a>2.2.4：二进制安全</h4><p>C字符串必须符合某种编码，且除了字符串末尾外，字符串里面不能包含空字符。这些限制使其只能保存文本数据，而不能保存图片、音频、视频、压缩文件等二进制数据。</p>
<p>所有SDS API都会以处理二进制的方式来处理buf数组（字节数组）里面的数据。SDS用len的值而不是空字符来判断字符串是否结束。</p>
<h4 id="2-2-5：兼容部分C字符串函数"><a href="#2-2-5：兼容部分C字符串函数" class="headerlink" title="2.2.5：兼容部分C字符串函数"></a>2.2.5：兼容部分C字符串函数</h4><p>SDS遵循C字符串以空字符结尾的惯例，这使得保存文本数据的SDS可以重用一部分<string.h>库定义的函数。</string.h></p>
<h4 id="2-2-6：总结"><a href="#2-2-6：总结" class="headerlink" title="2.2.6：总结"></a>2.2.6：总结</h4><div class="table-container">
<table>
<thead>
<tr>
<th>C字符串</th>
<th>SDS</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取字符串长度的复杂度为O(N)</td>
<td>获取字符串长度的复杂度为O(1)</td>
</tr>
<tr>
<td>API不安全，可能会造成缓冲区溢出</td>
<td>API安全，不会造成缓冲区溢出</td>
</tr>
<tr>
<td>修改字符串长度N次必然执行N次内存重分配</td>
<td>修改字符串长度N次最多执行N次内存重分配</td>
</tr>
<tr>
<td>只能保存文本数据</td>
<td>可以保存文本数据或二进制数据</td>
</tr>
<tr>
<td>可以使用<string.h>库中的所有函数</string.h></td>
<td>可以使用部分<string.h>库中的函数</string.h></td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-3：SDS-API"><a href="#2-3：SDS-API" class="headerlink" title="2.3：SDS API"></a>2.3：SDS API</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>sdsnew</td>
<td>创建包含给定C字符串的SDS</td>
<td>O(N)，N为字符串长度</td>
</tr>
<tr>
<td>sdsempty</td>
<td>创建不包含任何内容的空SDS</td>
<td>O(1)</td>
</tr>
<tr>
<td>sdsfree</td>
<td>释放给定的SDS</td>
<td>O(N)，N为被释放SDS的长度</td>
</tr>
<tr>
<td>sdslen</td>
<td>返回SDS已使用空间字节数</td>
<td>len属性，O(1)</td>
</tr>
<tr>
<td>sdsavail</td>
<td>返回SDS未使用空间字节数</td>
<td>free属性，O(1)</td>
</tr>
<tr>
<td>sdsdup</td>
<td>创建一个给定SDS的副本（copy）</td>
<td>O(N)</td>
</tr>
<tr>
<td>sdsclear</td>
<td>清空SDS保存的字符串内容</td>
<td>惰性空间释放，O(1)</td>
</tr>
<tr>
<td>sdscat</td>
<td>将给定C字符串拼接到SDS字符串末尾</td>
<td>O(N)，N为给定C字符串的长度</td>
</tr>
<tr>
<td>sdscatsds</td>
<td>将给定SDS字符串拼接到另一个SDS末尾</td>
<td>O(N)，N为给定SDS字符串的长度</td>
</tr>
<tr>
<td>sdscopy</td>
<td>将给定C字符串复制到SDS里，覆盖SDS原有字符串</td>
<td>O(N)，N为给定C字符串的长度</td>
</tr>
<tr>
<td>sdsgrowzero</td>
<td>用空字符将SDS扩展至给定长度</td>
<td>O(N)，N为新增字节数</td>
</tr>
<tr>
<td>sdsrange</td>
<td>保留SDS给定区间内数据，其他数据被覆盖或清除</td>
<td>O(N)，N为被保留数据字节数</td>
</tr>
<tr>
<td>sdstrim</td>
<td>接受一个SDS和一个C字符串作为参数，从SDS左右两端分别移除所有在C字符串中出现过的字符</td>
<td>O(M*N)，M为SDS长度，N为C字符串长度</td>
</tr>
<tr>
<td>sdscmp</td>
<td>比较两个SDS字符串是否相同</td>
<td>O(N)，N为较短SDS的长度</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2-4：重点回顾"><a href="#2-4：重点回顾" class="headerlink" title="2.4：重点回顾"></a>2.4：重点回顾</h3><p>Redis只会使用C字符串作为字面量，大多情况下，Redis使用SDS表示字符串。</p>
<p>SDS具有如下优点：</p>
<ul>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串长度时所需的内存重分配次数</li>
<li>二进制安全</li>
<li>兼容部分C字符串库函数</li>
</ul>
<h2 id="第3章：链表"><a href="#第3章：链表" class="headerlink" title="第3章：链表"></a>第3章：链表</h2><p>链表用在：列表键实现、发布与订阅、慢查询、监视器、保存客户端状态信息、构建客户端输出缓冲区等</p>
<h3 id="3-1：链表和链表节点的实现"><a href="#3-1：链表和链表节点的实现" class="headerlink" title="3.1：链表和链表节点的实现"></a>3.1：链表和链表节点的实现</h3><p>链表节点adlist.h/listNode</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 节点的值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125;listNode;</span><br></pre></td></tr></table></figure>
<p>使用adlist.h/list来持有链表，使链表操作更方便</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 链表包含的节点数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>
<p>dup、free、match成员用于实现多态链表所需的类型特定函数。</p>
<p>双端链表迭代器结构</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前迭代到的节点</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="comment">// 迭代的方向</span></span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br></pre></td></tr></table></figure>
<p>Redis链表实现特性：</p>
<ul>
<li>双端、无环（表头节点的prev和表尾节点的tail都指向NULL，对链表的访问以NULL为终点）</li>
<li>带表头指针和表尾指针（list结构的head指针和tail指针）</li>
<li>带链表长度计数器（list结构的len属性）</li>
<li>多态：链表节点使用void*指针保存节点值，且可以通过list结构的dup、free、match属性为节点值设置类型特定函数，所以链表可以保存各种类型的值。</li>
</ul>
<h3 id="3-2：链表和链表节点的API"><a href="#3-2：链表和链表节点的API" class="headerlink" title="3.2：链表和链表节点的API"></a>3.2：链表和链表节点的API</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>listSetDupMethod</td>
<td>将给定函数设置为链表的节点值复制函数</td>
</tr>
<tr>
<td>listGetDupMethod</td>
<td>返回链表当前正在使用的节点值复制函数</td>
</tr>
<tr>
<td>listSetFreeMethod</td>
<td>将给定函数设置为链表的节点值释放函数</td>
</tr>
<tr>
<td>listGetFree</td>
<td>返回链表当前正在使用的节点值释放函数</td>
</tr>
<tr>
<td>listSetMatchMethod</td>
<td>将给定函数设置为链表的节点值对比函数</td>
</tr>
<tr>
<td>listGetMatchMethod</td>
<td>返回链表当前正在使用的节点值对比函数</td>
</tr>
<tr>
<td>listLength</td>
<td>返回链表长度</td>
</tr>
<tr>
<td>listFirst</td>
<td>返回链表表头节点</td>
</tr>
<tr>
<td>listLast</td>
<td>返回链表表尾节点</td>
</tr>
<tr>
<td>listPrevNode</td>
<td>返回给定节点的前置节点</td>
</tr>
<tr>
<td>listNextNode</td>
<td>返回给定节点的后置节点</td>
</tr>
<tr>
<td>listNodeValue</td>
<td>返回给定节点当前保存的值</td>
</tr>
<tr>
<td>listCreate</td>
<td>创建一个不包含任何节点的新链表</td>
</tr>
<tr>
<td>listAddNodeHead</td>
<td>将一个新节点添加到链表表头</td>
</tr>
<tr>
<td>listAddNodeTail</td>
<td>将一个新节点添加到链表表尾</td>
</tr>
<tr>
<td>listInsertNode</td>
<td>将一个新节点添加到给定节点之前或之后</td>
</tr>
<tr>
<td>listSearchKey</td>
<td>查找并返回链表中包含给定值的节点</td>
</tr>
<tr>
<td>listIndex</td>
<td>返回链表在给定索引上的节点</td>
</tr>
<tr>
<td>listDelNode</td>
<td>从链表中删除给定节点</td>
</tr>
<tr>
<td>listRotate</td>
<td>将链表表尾节点弹出并插入到链表表头</td>
</tr>
<tr>
<td>listDup</td>
<td>复制一个给定链表的副本</td>
</tr>
<tr>
<td>listRelease</td>
<td>释放给定链表以及链表中的所有节点</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第4章：字典"><a href="#第4章：字典" class="headerlink" title="第4章：字典"></a>第4章：字典</h2><p>Redis数据库使用字典作为底层实现，对数据库的增删改查都基于字典的操作。</p>
<p>字典也是哈希键的底层实现之一。</p>
<h3 id="4-1：字典的实现"><a href="#4-1：字典的实现" class="headerlink" title="4.1：字典的实现"></a>4.1：字典的实现</h3><p>Redis字典使用哈希表作为底层实现，一个哈希表有多个哈希表节点，每个哈希表节点保存字典中的一个键值对。</p>
<h4 id="4-1-1：哈希表"><a href="#4-1-1：哈希表" class="headerlink" title="4.1.1：哈希表"></a>4.1.1：哈希表</h4><p>dict.h/dictht结构，其中table是一个数组，保存指向dict.h/dictEntry结构的指针，每个dictEntry保存一个键值对。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="comment">// 哈希表大小，即table数组大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="comment">// 该哈希表已有节点数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-2：哈希表节点"><a href="#4-1-2：哈希表节点" class="headerlink" title="4.1.2：哈希表节点"></a>4.1.2：哈希表节点</h4><p>dictEntry结构，保存键值对</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    viod *key;</span><br><span class="line">    <span class="comment">// 值，可以是一个指针、uint64_t整数或int64_t整数</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，链地址法解决哈希冲突</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure>
<h4 id="4-1-3：字典"><a href="#4-1-3：字典" class="headerlink" title="4.1.3：字典"></a>4.1.3：字典</h4><p>dict.h/dict结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span>&#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// rehash索引</span></span><br><span class="line">    <span class="comment">// 当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;</span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure>
<p>type和privdata属性针对不同类型的键值对，为创建多态字典设置：</p>
<ul>
<li>type属性为指向dictType结构的指针，每个dictType保存一簇用于操作特定类型键值对的函数。</li>
<li>privdata属性保存需要传给类型特定函数的可选参数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span>&#123;</span></span><br><span class="line">    <span class="comment">// 计算哈希值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// 复制键的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制值的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比键的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata,<span class="keyword">const</span> <span class="keyword">void</span> *key1,<span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="comment">// 销毁键的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata,<span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁值的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata,<span class="keyword">void</span> *obj);</span><br><span class="line">&#125;dictType;</span><br></pre></td></tr></table></figure>
<p>ht属性是一个包含两个项的数组，其中每项是一个dictht哈希表，ht[1]只会在对ht[0]进行rehash时使用。</p>
<p>rehashidx属性记录目前rehash的进度，若没有进行rehash，其值为-1。</p>
<h3 id="4-2：哈希算法"><a href="#4-2：哈希算法" class="headerlink" title="4.2：哈希算法"></a>4.2：哈希算法</h3><p>当要将一个新的键值对添加到字典里时，程序先根据键计算哈希值和索引值，然后根据索引值将包含新键值对的哈希表节点放到哈希表数组中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用字典设置的哈希函数，计算键key的哈希值</span></span><br><span class="line">hash=dict-&gt;type-&gt;hashFunction(key);</span><br><span class="line"><span class="comment">// 使用哈希表的sizemask和哈希值，计算索引值</span></span><br><span class="line"><span class="comment">// 根据情况不同，ht[x]可以是ht[0]或ht[1]</span></span><br><span class="line">index=hash &amp; dict-&gt;ht[x].sizemask;</span><br></pre></td></tr></table></figure>
<p>当字典用于数据库或哈希键底层实现时，Redis使用MurmurHash2算法计算键的哈希值。该算法优点在于，即使输入的键是有规律的，算法仍有很好的随机分布性，且算法的计算速度非常快。</p>
<h3 id="4-3：解决键冲突"><a href="#4-3：解决键冲突" class="headerlink" title="4.3：解决键冲突"></a>4.3：解决键冲突</h3><p>Redis的哈希表使用链地址法来解决键冲突。</p>
<p>因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度，程序总将新节点添加到链表表头。</p>
<h3 id="4-4：Rehash"><a href="#4-4：Rehash" class="headerlink" title="4.4：Rehash"></a>4.4：Rehash</h3><p>随着操作不断执行，哈希表中的键值对会逐渐增多或减少，为了让哈希表的负载因子维持在合理范围，程序需要对哈希表大小进行扩展或收缩。rehash(重散列)步骤如下：</p>
<ol>
<li>为字典的ht[1]哈希表分配空间，大小取决于执行的操作以及ht[0]当前包含的键值对数量（ht[0].used）<ul>
<li>若执行扩展操作，ht[1]的大小为第一个大于等于ht[0].used<em>2的<em>*$2^n$</em></em>；</li>
<li>若执行收缩操作，ht[1]的大小为第一个大于等于ht[0].used的<strong>$2^n$</strong>。</li>
</ul>
</li>
<li>将ht[0]中的所有键值对rehash到ht[1]上：rehash指重新计算键的哈希值和索引值，然后将键值对放到ht[1]的指定位置。</li>
<li>当ht[0]包含的所有键值对都<strong>迁移</strong>到了ht[1]后（ht[0]变为空表），释放ht[0]，将ht[1]设为ht[0]，最后为ht[1]分配一个空白哈希表，为下一次rehash做准备。</li>
</ol>
<p><strong>哈希表的扩展与收缩</strong></p>
<p>当以下条件任意一个被满足时，程序会自动对哈希表执行扩展操作：</p>
<ol>
<li>服务器目前没执行BGSAVE或BGREWRITEAOF命令，且哈希表负载因子大于等于1。</li>
<li>服务器正在执行BGSAVE或BGREWRITEAOF命令，且哈希表负载因子大于等于5。</li>
</ol>
<p>哈希表负载因子=哈希表已保存节点数量/哈希表大小：load_factor=ht[0].used/ht[0].size</p>
<p>在执行BGSAVE或BGREWRITEAOF命令时，需要创建当前服务器进程的子进程，且大多OS都采用<strong>写时复制</strong>技术优化子进程效率。所以在子进程存在期间，服务器会提高执行扩展操作的负载因子，从而尽可能避免在子进程存在期间进行哈希表扩展，避免不必要的内存写入操作，最大限度节约内存（写内存时会复制）</p>
<p>当负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。</p>
<h3 id="4-5：渐进式rehash"><a href="#4-5：渐进式rehash" class="headerlink" title="4.5：渐进式rehash"></a>4.5：渐进式rehash</h3><p>当扩展或收缩哈希表时，rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。原因在于如果哈希表保存的键值对数量很庞大时，要一次性将其rehash的话，可能会导致服务器在一段时间内停止服务。以下是哈希表渐进式rehash的步骤：</p>
<ol>
<li>为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</li>
<li>在字典中维持一个索引计数器变量rehashidx，并将其设为0，表示rehash工作开始</li>
<li>在rehash期间，每次对字典执行增删改查操作时，程序除了执行该指定操作，还会顺便将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，然后将rehashidx加一。</li>
<li>随着对字典不断操作，最终ht[0]所有键值对都会被rehash到ht[1]，这时程序将rehashidx设为-1，表示rehash操作完成。</li>
</ol>
<p>渐进式rehash将rehash键值对所需的计算工作均摊到对字典的每个增删改查操作上，避免了集中式rehash带来的庞大计算量。</p>
<p><strong>渐进式rehash执行期间的哈希表操作</strong></p>
<p>因为在渐进式rehash期间，字典会同时使用ht[0]和ht[1]，所以在此期间，字典的删除、更新、查找操作会在两个哈希表上进行。例如，查找会先在ht[0]查找，没找到会在ht[1]继续查找。</p>
<p>另外，在渐进式rehash期间，新添加到字典的键值对会一律保存到ht[1]中，ht[0]上不进行任何添加操作，保证ht[0]包含的键值对数量不断减少，并随着rehash操作最终变为空表。</p>
<h3 id="4-6：字典API"><a href="#4-6：字典API" class="headerlink" title="4.6：字典API"></a>4.6：字典API</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>dictCreate</td>
<td>创建新字典O(1)</td>
</tr>
<tr>
<td>dictAdd</td>
<td>添加给定键值对O(1)</td>
</tr>
<tr>
<td>dictReplace</td>
<td>添加给定键值对，如果键已经存在，替换其值O(1)</td>
</tr>
<tr>
<td>dictFetchValue</td>
<td>返回给定键的值O(1)</td>
</tr>
<tr>
<td>dictGetRandomKey</td>
<td>随机返回一个键值对O(1)</td>
</tr>
<tr>
<td>dictDelete</td>
<td>删除给定键的键值对O(1)</td>
</tr>
<tr>
<td>dictRelease</td>
<td>释放字典以及字典中的所有键值对O(N)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第5章：跳跃表"><a href="#第5章：跳跃表" class="headerlink" title="第5章：跳跃表"></a>第5章：跳跃表</h2><p>有序数据结构，通过在每个节点中维持多个指向其他节点的指针来达到快速访问节点的目的。支持平均$O(logN)$、最坏$O(N)$复杂度的节点查找，还能通过顺序性操作来批量处理节点。Redis使用跳跃表作为有序集合键的底层实现之一。</p>
<p>Redis只在两个地方用到了跳跃表：实现有序集合键、在集群节点中用作内部数据结构</p>
<h3 id="5-1：跳跃表的实现"><a href="#5-1：跳跃表的实现" class="headerlink" title="5.1：跳跃表的实现"></a>5.1：跳跃表的实现</h3><p>Redis跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，前者表示跳跃表节点，后者保存跳跃表相关信息（节点数量、表头节点、表尾节点等）</p>
<h4 id="5-1-1：跳跃表节点"><a href="#5-1-1：跳跃表节点" class="headerlink" title="5.1.1：跳跃表节点"></a>5.1.1：跳跃表节点</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>&#123;</span></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span>&#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125;level[];</span><br><span class="line">&#125;zskiplistNode;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>层</strong>：跳跃表节点的level数组可包含多个元素，每个元素包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度。每次创建一个新的跳跃表节点时，都根据幂次定律（越大的数出现的概率越小）随机生成一个介于1到32之间的值作为level数组的大小，该大小为层的“高度”。</li>
<li><strong>前进指针</strong>：每个层包含一个指向表尾方向的前进指针。</li>
<li><strong>跨度</strong>：用于记录两个节点间的距离。指向NULL的所有前进指针跨度为0。<strong>跨度用来计算排位</strong>：在查找某个节点时，将沿途经过的层的跨度累计便得到目标节点在跳跃表中的排位</li>
<li><strong>后退指针</strong>：用于反向访问跳跃表，只有一个。</li>
<li><strong>分值和成员</strong>：分值为double类型，所有节点按分值从小到大排序；成员对象是一个指针，指向SDS对象。在同一跳跃表中，各节点保存的成员对象必须唯一，而分值可以相等：分值相等则按成员对象字典序排序</li>
<li>只会用到表头节点的各个层，其他属性不会被用到。</li>
</ul>
<h4 id="5-1-2：跳跃表"><a href="#5-1-2：跳跃表" class="headerlink" title="5.1.2：跳跃表"></a>5.1.2：跳跃表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span>&#123;</span></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>,*<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 表中节点数量（不含表头节点）</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 表中层数最大节点的层数（不含表头节点）</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125;zskiplist;</span><br></pre></td></tr></table></figure>
<h3 id="5-2：跳跃表API"><a href="#5-2：跳跃表API" class="headerlink" title="5.2：跳跃表API"></a>5.2：跳跃表API</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>zslCreate</td>
<td>创建跳跃表</td>
<td>O(1)</td>
</tr>
<tr>
<td>zslFree</td>
<td>释放跳跃表及其所有节点</td>
<td>O(N)</td>
</tr>
<tr>
<td>zslInsert</td>
<td>将包含给定成员和分值的节点加入跳跃表</td>
<td>平均O(logN)，最坏O(N)</td>
</tr>
<tr>
<td>zslDelete</td>
<td>删除包含给定成员和分值的节点</td>
<td>平均O(logN)，最坏O(N)</td>
</tr>
<tr>
<td>zslGetRank</td>
<td>返回给定节点的排位</td>
<td>平均O(logN)，最坏O(N)</td>
</tr>
<tr>
<td>zslGetElementByRank</td>
<td>返回给定排位上的节点</td>
<td>平均O(logN)，最坏O(N)</td>
</tr>
<tr>
<td>zslIsInRange</td>
<td>给定一个范围，判断其是否包含在跳跃表的分值范围内</td>
<td>O(1)，通过表头节点和表尾节点</td>
</tr>
<tr>
<td>zslFirstInRange</td>
<td>给定一个范围，返回跳跃表中第一个分值在范围内的节点</td>
<td>平均O(logN)，最坏O(N)</td>
</tr>
<tr>
<td>zslLastInRange</td>
<td>给定一个范围，返回跳跃表中最后一个分值在范围内的节点</td>
<td>平均O(logN)，最坏O(N)</td>
</tr>
<tr>
<td>zslDeleteRangeByScore</td>
<td>给定一个范围，删除跳跃表中所有分值在范围内的节点</td>
<td>O(N)，N为被删节点数</td>
</tr>
<tr>
<td>zslDeleteRangeByRank</td>
<td>给定一个范围，删除跳跃表中所有排位在范围内的节点</td>
<td>O(N)，N为被删节点数</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第6章：整数集合"><a href="#第6章：整数集合" class="headerlink" title="第6章：整数集合"></a>第6章：整数集合</h2><p>当一个集合只包含整数值元素，且元素数量不多时，Redis使用整数集合作为集合键的底层实现。</p>
<h3 id="6-1：整数集合的实现"><a href="#6-1：整数集合的实现" class="headerlink" title="6.1：整数集合的实现"></a>6.1：整数集合的实现</h3><p>整数集合可以保存int16_t、int32_t、或int64_t的整数值，并且会保证集合中无重复元素。</p>
<p>intset.h/intset结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;intset;</span><br></pre></td></tr></table></figure>
<p>整数集合的每个元素是contents数组的数据项，各项在数组中从小到大排列，且数组中无重复项。</p>
<p>虽然intset结构将contents声明为int8_t，但该数组并不保存任何int8_t类型的值，其真正类型取决于encoding的值：INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64。</p>
<h3 id="6-2：升级"><a href="#6-2：升级" class="headerlink" title="6.2：升级"></a>6.2：升级</h3><p>每当将一个新元素添加到整数集合中，且新元素类型比整数集合当前类型要长时，整数集合要进行升级，然后才能添加新元素。步骤如下：</p>
<ol>
<li>根据新元素类型，扩展整数集合底层数组，并为新元素分配空间。（集合元素+新元素）</li>
<li>将底层数组当前所有元素转换成与新元素相同的类型，并将其放在正确的比特位上，且维持有序性。</li>
<li>将新元素添加进底层数组中，同时更改encoding属性和length属性。</li>
</ol>
<p><strong>升级后新元素摆放位置</strong></p>
<p>引发升级的新元素的长度总比整数集合所有元素的长度都大，所以新元素的值要么大于所有元素，要么小于所有元素：大于则新元素放在底层数组末尾，小于则放在开头。</p>
<h3 id="6-3：升级的好处"><a href="#6-3：升级的好处" class="headerlink" title="6.3：升级的好处"></a>6.3：升级的好处</h3><h4 id="6-3-1：提高灵活性"><a href="#6-3-1：提高灵活性" class="headerlink" title="6.3.1：提高灵活性"></a>6.3.1：提高灵活性</h4><p>因为C语言是静态类型语言，为了避免类型错误，不会将两种不同类型的数据放在同一个数据结构中。但是整数集合可以通过自动升级底层数组来存放新元素，所以能随意添加int16_t、int32_t、int64_t类型的数据。</p>
<h4 id="6-3-2：节约内存"><a href="#6-3-2：节约内存" class="headerlink" title="6.3.2：节约内存"></a>6.3.2：节约内存</h4><p>整数集合能添加三种不同类型的值，且能确保升级操作只会在有需要时进行，尽量节省内存。</p>
<h3 id="6-4：降级"><a href="#6-4：降级" class="headerlink" title="6.4：降级"></a>6.4：降级</h3><p>整数集合不支持降级操作，一旦升级，编码会一直保持升级后的状态。</p>
<h3 id="6-5：整数集合API"><a href="#6-5：整数集合API" class="headerlink" title="6.5：整数集合API"></a>6.5：整数集合API</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>intsetNew</td>
<td>创建整数集合</td>
<td>O(1)</td>
</tr>
<tr>
<td>intsetAdd</td>
<td>添加给定元素到整数集合</td>
<td>可能会升级，O(N)</td>
</tr>
<tr>
<td>intsetRemove</td>
<td>移除给定元素</td>
<td>O(N)</td>
</tr>
<tr>
<td>intsetFind</td>
<td>查找给定元素</td>
<td>排好序了，O(logN)</td>
</tr>
<tr>
<td>intsetRandom</td>
<td>随机返回一个元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>intsetGet</td>
<td>返回给定索引上的元素</td>
<td>O(1)</td>
</tr>
<tr>
<td>intsetLen</td>
<td>返回整数集合元素个数</td>
<td>O(1)</td>
</tr>
<tr>
<td>intsetBlobLen</td>
<td>返回整数集合占用字节数</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第7章：压缩列表"><a href="#第7章：压缩列表" class="headerlink" title="第7章：压缩列表"></a>第7章：压缩列表</h2><p>压缩列表（ziplist）是列表键和哈希键的底层实现之一：</p>
<ol>
<li>当一个列表键只包含少量列表项，且每个列表项是小整数值或长度较短的字符串时</li>
<li>当一个哈希键只包含少量键值对，且每个键值对的键和值是小整数值或长度较短的字符串时</li>
</ol>
<h3 id="7-1：压缩列表的构成"><a href="#7-1：压缩列表的构成" class="headerlink" title="7.1：压缩列表的构成"></a>7.1：压缩列表的构成</h3><p>压缩列表是redis为了节约内存开发的，是由一系列特殊编码的连续内存块组成的顺序型结构。一个压缩列表可以包含任意个节点（entry），每个节点保存一个字节数组或一个整数值。</p>
<p>压缩列表各组成部分如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>zlbytes</td>
<td>uint32_t</td>
<td>4字节</td>
<td>记录整个压缩列表占用的字节数：在内存重分配或计算zlend时使用</td>
</tr>
<tr>
<td>zltail</td>
<td>uint32_t</td>
<td>4字节</td>
<td>记录表尾节点距离起始地址的字节数</td>
</tr>
<tr>
<td>zllen</td>
<td>uint16_t</td>
<td>2字节</td>
<td>记录压缩列表的节点数：当该值等于UINT16_MAX(65535)时，真实数量需要遍历整个列表得到；小于65535时可用</td>
</tr>
<tr>
<td>entryX</td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表节点的长度由节点保存的内容决定</td>
</tr>
<tr>
<td>zlend</td>
<td>uint8_t</td>
<td>1字节</td>
<td>特殊值0xFF(十进制255)，用于标记列表末端</td>
</tr>
</tbody>
</table>
</div>
<h3 id="7-2-压缩列表节点的构成"><a href="#7-2-压缩列表节点的构成" class="headerlink" title="7.2:压缩列表节点的构成"></a>7.2:压缩列表节点的构成</h3><p>每个压缩列表节点可以保存一个字节数组或一个整数值：</p>
<ol>
<li>字节数组的长度可以是：小于等于63($2^6-1$)、16383($2^{14}-1$)或($2^{32}-1$)字节。</li>
<li>整数值长度可以是：4位(0-12之间的无符号整数)、1字节或3字节有符号整数、int16_t、int32_t、int64_t类型的整数。</li>
</ol>
<p>每个压缩列表节点都由previous_entry_length、encoding、content三部分组成。</p>
<h4 id="7-2-1：previous-entry-length"><a href="#7-2-1：previous-entry-length" class="headerlink" title="7.2.1：previous_entry_length"></a>7.2.1：previous_entry_length</h4><p>记录前一个节点包含的字节数，该属性长度可以是1字节或5字节：</p>
<ul>
<li>若前一节点字节数小于254，则该属性为1字节。</li>
<li>否则，该属性为5字节：第一个字节为0xEE(254)，之后四字节用于保存前一节点长度。</li>
</ul>
<p>程序可以通过指针运算，根据当前节点的起始地址计算前一个节点的起始地址，且可以一直回溯到表头节点。</p>
<h4 id="7-2-2：encoding"><a href="#7-2-2：encoding" class="headerlink" title="7.2.2：encoding"></a>7.2.2：encoding</h4><p>encoding属性记录节点的content属性所保存数据的<strong>类型和长度</strong>：</p>
<p>字节数组编码：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>00bbbbbb</td>
<td>1字节</td>
<td>长度小于等于($2^6-1$)字节的字节数组</td>
</tr>
<tr>
<td>01bbbbbb xxxxxxxx</td>
<td>2字节</td>
<td>长度小于等于($2^{14}-1$)字节的字节数组</td>
</tr>
<tr>
<td>10<strong>____</strong> aaaaaaaa bbbbbbbb cccccccc dddddddd</td>
<td>5字节</td>
<td>长度小于等于($2^{32}-1$)字节的字节数组</td>
</tr>
</tbody>
</table>
</div>
<p>整数编码：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编码</th>
<th>编码长度</th>
<th>content属性保存的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>11000000</td>
<td>1字节</td>
<td>int16_t类型的整数</td>
</tr>
<tr>
<td>11010000</td>
<td>1字节</td>
<td>int32_t类型的整数</td>
</tr>
<tr>
<td>11100000</td>
<td>1字节</td>
<td>int64_t类型的整数</td>
</tr>
<tr>
<td>11110000</td>
<td>1字节</td>
<td>3字节有符号整数</td>
</tr>
<tr>
<td>11111110</td>
<td>1字节</td>
<td>1字节有符号整数</td>
</tr>
<tr>
<td>1111xxxx</td>
<td>1字节</td>
<td>使用这一编码的节点无content属性，xxxx四位保存(0,12)之间的值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="7-2-3：content"><a href="#7-2-3：content" class="headerlink" title="7.2.3：content"></a>7.2.3：content</h4><p>节点的content属性保存节点的值，节点值可以是一个字节数组或整数，其类型和长度由节点的encoding属性决定。</p>
<h3 id="7-3：连锁更新"><a href="#7-3：连锁更新" class="headerlink" title="7.3：连锁更新"></a>7.3：连锁更新</h3><p>每个节点的previous_entry_length属性都记录了前一个节点的长度，如果前一节点长度小于254字节，该属性需要一字节，否则需要5字节。当在压缩列表中插入或删除节点时，可能会对压缩列表节点的previous_entry_length属性执行空间重分配操作（由于内存连续，每次内存重分配需要复杂度O(N)），从而引起后面一系列节点的空间重分配操作，Redis将这种特殊情况下产生的连续多次空间扩展操作称为“连锁更新”。连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，每次内存重分配最坏复杂度为O(N)，所以连锁更新最坏复杂度为O(N方)。</p>
<p>尽管连锁更新复杂度较高，但它造成性能问题的几率很低：</p>
<ol>
<li>压缩列表中要恰好有多个连续的、长度介于250字节到253字节之间的节点才有可能引发连锁更新。</li>
<li>即使出现连锁更新，只要数量不多，就不会对性能造成影响。</li>
</ol>
<p>基于以上原因，ziplistPush等命令的平均复杂度仅为O(N)，实际中可以放心使用</p>
<h3 id="7-4：压缩列表API"><a href="#7-4：压缩列表API" class="headerlink" title="7.4：压缩列表API"></a>7.4：压缩列表API</h3><div class="table-container">
<table>
<thead>
<tr>
<th>函数</th>
<th>作用</th>
<th>复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>ziplistNew</td>
<td>创建压缩列表</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistPush</td>
<td>创建包含给定值的新节点，并将节点添加到表头或表尾</td>
<td>平均O(N)，最坏O(N方)</td>
</tr>
<tr>
<td>ziplistInsert</td>
<td>将包含给定值的新节点插入到给定地址</td>
<td>平均O(N)，最坏O(N方)</td>
</tr>
<tr>
<td>ziplistIndex</td>
<td>返回压缩列表给定索引上的节点</td>
<td>O(N)</td>
</tr>
<tr>
<td>ziplistFind</td>
<td>查找并返回包含给定值的节点</td>
<td>节点值可能为字节数组，需要O(N)复杂度来判断节点值是否和给定值相等，所以查找整个列表的复杂度为O(N方)</td>
</tr>
<tr>
<td>ziplistNext</td>
<td>返回给定节点的下一个节点</td>
<td>O(1)，每个节点占用字节数可以计算得到</td>
</tr>
<tr>
<td>ziplistPrev</td>
<td>返回给定节点的前一个节点</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistGet</td>
<td>返回给定节点保存的值</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistDelete</td>
<td>删除压缩列表中给定地址上的节点</td>
<td>平均O(N)，最坏O(N方)</td>
</tr>
<tr>
<td>ziplistDeleteRange</td>
<td>删除压缩列表在给定索引上的连续多个节点</td>
<td>平均O(N)，最坏O(N方)</td>
</tr>
<tr>
<td>ziplistBlobLen</td>
<td>返回压缩列表占用的内存字节数</td>
<td>O(1)</td>
</tr>
<tr>
<td>ziplistLen</td>
<td>返回压缩列表包含的节点数</td>
<td>节点数小于65535时O(1)，否则为O(N)</td>
</tr>
</tbody>
</table>
</div>
<h2 id="第8章：对象"><a href="#第8章：对象" class="headerlink" title="第8章：对象"></a>第8章：对象</h2><p>在前面各章节中，介绍了Redis用到的所有数据结构：简单动态字符串(SDS)、双端链表、字典、压缩列表、整数集合、跳跃表。Redis基于这些数据结构创建了一个对象系统，包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象。Redis可以在执行命令前根据对象类型判断一个对象是否能执行给定命令；可以针对不同使用场景为对象设置多种数据结构的实现，优化对象使用效率。</p>
<p>Redis对象系统实现了基于引用计数的内存回收机制，当程序不再使用某对象时，其内存会被自动释放；Redis还实现了基于引用计数的对象共享机制，可以通过让多个数据库键共享同一个对象来节约内存；Redis对象带有访问时间记录信息，可用于计算数据库键的空转时间，在服务器启用maxmemory功能时，空转时长大的键会优先被删除。</p>
<h3 id="8-1：对象的类型与编码"><a href="#8-1：对象的类型与编码" class="headerlink" title="8.1：对象的类型与编码"></a>8.1：对象的类型与编码</h3><p>Redis使用对象来表示数据库中的键和值，每当创建一个键值对，至少会创建两个对象，一个用作键（键对象），一个用作值（值对象）。每个对象由redisObject结构表示，其中和保存数据有关的三个属性如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 指向底层数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"> 	<span class="comment">// ...</span></span><br><span class="line">&#125;robj;</span><br></pre></td></tr></table></figure>
<h4 id="8-1-1-类型"><a href="#8-1-1-类型" class="headerlink" title="8.1.1:类型"></a>8.1.1:类型</h4><p>类型可以是：REDIS_STRING、REDIS_LIST、REDIS_HASH、REDIS_SET、REDIS_ZSET</p>
<p>键总是一个字符串对象，而值可以是五种对象的其中一种，因此当称呼一个键为“列表键”时，指“该数据库键所对应的值为列表对象”。TYPE命令返回数据库键所对应的值对象的类型。</p>
<h4 id="8-1-2：编码和底层实现"><a href="#8-1-2：编码和底层实现" class="headerlink" title="8.1.2：编码和底层实现"></a>8.1.2：编码和底层实现</h4><p>对象的ptr指针指向对象的底层数据结构，这些数据结构由encoding属性决定。encoding属性的值可以是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码对应的底层数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_ENCODING_INT</td>
<td>long类型整数</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr编码的简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
</tr>
</tbody>
</table>
</div>
<p>每种对象类型都至少使用了两种编码，即至少有两种底层实现：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>编码</th>
<th>对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_INT</td>
<td>使用整数值实现的字符串对象</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>使用embstr编码的SDS实现的字符串对象</td>
</tr>
<tr>
<td>REDIS_STRING</td>
<td>REDIS_ENCODING_RAW</td>
<td>使用简单动态字符串(SDS)实现的字符串对象</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的列表对象</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>使用双端链表实现的列表对象</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的哈希对象</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的哈希对象</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_INTSET</td>
<td>使用整数集合实现的集合对象</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>REDIS_ENCODING_HT</td>
<td>使用字典实现的集合对象</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>使用压缩列表实现的有序集合对象</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>使用跳跃表和字典实现的有序集合对象</td>
</tr>
</tbody>
</table>
</div>
<p>通过OBJECT ENCODING命令可查看一个数据库键的值对象所使用的编码。</p>
<p>通过encoding属性设定对象所使用的编码，而不是为对象关联一种固定的编码，极大地提高了Redis的灵活性，Redis可以根据不同场景为对象设置合适的编码：</p>
<ul>
<li>因为压缩列表比双端链表更节约内存，且元素较少时，在内存中连续存放的压缩列表可以更快载入缓存</li>
<li>随着列表对象包含的元素越来越多，使用压缩列表的优势消失时，对象的底层实现会转向双端链表。</li>
</ul>
<h3 id="8-2：字符串对象"><a href="#8-2：字符串对象" class="headerlink" title="8.2：字符串对象"></a>8.2：字符串对象</h3><p>字符串对象的编码可以是int、raw或embstr。</p>
<ul>
<li>如果一个字符串对象保存的是整数值，且可以用long类型来表示，那么字符串对象会将整数值保存在ptr属性中（将void*转换成long），并将编码设置为int。</li>
<li>如果字符串对象保存的是字符串值，且长度大于39字节，那么使用SDS来保存该字符串，且编码为raw。</li>
<li>如果字符串对象保存的是字符串值，且长度小于等于39，则使用embstr编码方式来保存。</li>
<li>embstr编码与raw编码一样，都使用redisObject和sdshdr来表示字符串对象。但raw编码会调用两次内存分配函数分别创建redisObject和sdshdr结构，而embstr调用一次内存分配函数来分配一块连续空间，空间依次包含redisObject和sdshdr结构。</li>
<li>embstr编码的内存分配和内存释放都只需要调用一次，且能利用缓存带来的优势。</li>
<li>可以用long double类型表示的浮点数在Redis中也作为字符串值来保存，编码为embstr或raw。</li>
<li>因为长度太大而无法用long表示的整数或无法用long double表示的浮点数用embstr或raw编码。</li>
</ul>
<h4 id="8-2-1：编码的转换"><a href="#8-2-1：编码的转换" class="headerlink" title="8.2.1：编码的转换"></a>8.2.1：编码的转换</h4><p>对于int编码的字符串对象，若向该对象执行某些命令（eg:append）使其不再是一个整数值，其编码变为raw。</p>
<p>另外，因为Redis没有为embstr编码的字符串对象编写任何修改程序，所以embstr编码的字符串对象是只读的。当对其进行修改时，程序会将其编码从embstr转换为raw，再进行修改。所以embstr编码的字符串在执行修改命令之后总会变成一个raw编码的字符串对象。</p>
<h4 id="8-2-2：字符串命令的实现"><a href="#8-2-2：字符串命令的实现" class="headerlink" title="8.2.2：字符串命令的实现"></a>8.2.2：字符串命令的实现</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>int编码</th>
<th>embstr编码</th>
<th>raw编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET</td>
<td>用int编码保存值</td>
<td>用embstr编码保存值</td>
<td>用raw编码保存值</td>
</tr>
<tr>
<td>GET</td>
<td>拷贝整数值，转换为字符串值，再向客户端返回</td>
<td>直接返回</td>
<td>直接返回</td>
</tr>
<tr>
<td>APPEND</td>
<td>将对象转换为raw编码，再按raw编码方式执行</td>
<td>转换为raw编码再执行</td>
<td>调用sdscatlen函数，将给定字符串追加到末尾</td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td>取出整数值转换为long double，进行加法，将浮点数结果保存</td>
<td>取出字符串值并尝试将其转换为long double，进行加法，再将浮点数结果保存。若不能转换，向客户端返回错误</td>
<td>同embstr</td>
</tr>
<tr>
<td>INCRBY</td>
<td>对整数值进行加法，结果作为整数保存</td>
<td>不能执行，返回错误</td>
<td>同embstr</td>
</tr>
<tr>
<td>DECRBY</td>
<td>对整数值进行减法，结果作为整数保存</td>
<td>不能执行，返回错误</td>
<td>同</td>
</tr>
<tr>
<td>STRLEN</td>
<td>拷贝整数转换为字符串，返回字符串长度</td>
<td>调用sdslen，返回长度</td>
<td>同</td>
</tr>
<tr>
<td>SETRANGE</td>
<td>转换为raw编码，按raw编码执行</td>
<td>同int编码</td>
<td>将字符串给定索引上的值设置为给定字符</td>
</tr>
<tr>
<td>GETRANGE</td>
<td>拷贝整数值转换为字符串，取出给定索引上的字符</td>
<td>直接取出给定索引上的字符</td>
<td>同</td>
</tr>
</tbody>
</table>
</div>
<h3 id="8-3：列表对象"><a href="#8-3：列表对象" class="headerlink" title="8.3：列表对象"></a>8.3：列表对象</h3><p>列表对象的编码可以是ziplist或linkedlist。</p>
<h4 id="8-3-1：编码转换"><a href="#8-3-1：编码转换" class="headerlink" title="8.3.1：编码转换"></a>8.3.1：编码转换</h4><p>当列表对象同时满足以下两个条件时，使用ziplist编码：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于64字节；</li>
<li>列表对象保存的元素数量小于512个。不能满足这两个条件的列表对象使用linkedlist编码。</li>
</ul>
<p>以上两个条件的上限值可以修改，配置文件中list-max-ziplist-value和list-max-ziplist-entries</p>
<p>当使用ziplist编码的列表对象不能满足条件时，会执行对象的编码转换操作，将保存在压缩列表中的所有列表元素转移到双端链表中，编码变为linkedlist。</p>
<h4 id="8-3-2：列表命令的实现"><a href="#8-3-2：列表命令的实现" class="headerlink" title="8.3.2：列表命令的实现"></a>8.3.2：列表命令的实现</h4><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>ziplist编码</th>
<th>linkedlist编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>LPUSH</td>
<td>调用ziplistPush，将新元素推入表头</td>
<td>调用listAddNodeHead，将新元素插入表头</td>
</tr>
<tr>
<td>RPUSH</td>
<td>调用ziplistPush，将新元素推入表尾</td>
<td>调用listAddNodeTail，将新元素插入表尾</td>
</tr>
<tr>
<td>LPOP</td>
<td>调用ziplistIndex定位表头，向用户返回节点保存的元素后调用ziplistDelete删除表头</td>
<td>调用listFirst定位表头，返回节点保存的元素后调用listDelNode删除表头</td>
</tr>
<tr>
<td>RPOP</td>
<td>调用ziplistIndex定位表尾，向用户返回节点保存的元素后调用ziplistDelete删除表尾</td>
<td>调用listLast定位表尾，返回节点保存的元素后调用listDelNode删除表尾</td>
</tr>
<tr>
<td>LINDEX</td>
<td>调用ziplistIndex定位指定节点，向用户返回节点保存的元素</td>
<td>调用listIndex定位指定节点，向用户返回节点保存的元素</td>
</tr>
<tr>
<td>LINSERT</td>
<td>插入新节点到表头或表尾时，使用ziplistPush；其他位置使用ziplistInsert。</td>
<td>调用listInsertNode</td>
</tr>
<tr>
<td>LREM</td>
<td>遍历压缩列表，调用ziplistDelete删除包含了给定元素的节点</td>
<td>遍历双端链表，调用listDelNode删除包含给定元素的节点</td>
</tr>
<tr>
<td>LTRIM</td>
<td>调用ziplistDeleteRange，删除压缩列表中所有不在指定索引范围内的节点</td>
<td>遍历双端链表，调用listDelNode删除链表中所有不在指定索引范围内的节点</td>
</tr>
<tr>
<td>LLEN</td>
<td>调用ziplistLen返回压缩列表的长度</td>
<td>调用listLength返回双端链表长度</td>
</tr>
<tr>
<td>LSET</td>
<td>先调用ziplistDelete删除指定索引上的节点，再调用ziplistInsert将包含给定元素的新节点插入到相同索引上</td>
<td>调用listIndex定位指定索引上的节点，然后通过赋值操作更新节点值</td>
</tr>
</tbody>
</table>
</div>
<h3 id="8-4：哈希对象"><a href="#8-4：哈希对象" class="headerlink" title="8.4：哈希对象"></a>8.4：哈希对象</h3>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/redis/" rel="tag"># redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/25/腾讯面试抱佛脚/" rel="next" title="腾讯面试抱佛脚">
                <i class="fa fa-chevron-left"></i> 腾讯面试抱佛脚
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/15/VIM配置YouCompleteMe/" rel="prev" title="VIM配置YouCompleteMe">
                VIM配置YouCompleteMe <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="http://chungen.coding.me/pics/favicon.png" alt="Chungen">
          <p class="site-author-name" itemprop="name">Chungen</p>
           
              <p class="site-description motion-element" itemprop="description">所谓自由，不是随心所欲，而是自我主宰！</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">9</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/cosensible" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.cnblogs.com/chungen" target="_blank" title="博客园">
                  
                    <i class="fa fa-fw fa-custom bokeyuan"></i>
                  
                    
                      博客园
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.jianshu.com/u/c29ee0a33277" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-custom jianshu"></i>
                  
                    
                      简书
                    
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://me.csdn.net/grooting" target="_blank" title="CSDN">
                  
                    <i class="fa fa-fw fa-custom csdn"></i>
                  
                    
                      CSDN
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis-设计与实现"><span class="nav-text">Redis 设计与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第1章：概览"><span class="nav-text">第1章：概览</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第一部分：数据结构与对象"><span class="nav-text">第一部分：数据结构与对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第2章：简单动态字符串（SDS）"><span class="nav-text">第2章：简单动态字符串（SDS）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1：SDS的定义"><span class="nav-text">2.1：SDS的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2：SDS与C字符串的区别"><span class="nav-text">2.2：SDS与C字符串的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1：常数复杂度获取字符串长度"><span class="nav-text">2.2.1：常数复杂度获取字符串长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2：杜绝缓冲区溢出"><span class="nav-text">2.2.2：杜绝缓冲区溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3：减少修改字符串带来的内存重分配次数"><span class="nav-text">2.2.3：减少修改字符串带来的内存重分配次数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4：二进制安全"><span class="nav-text">2.2.4：二进制安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-5：兼容部分C字符串函数"><span class="nav-text">2.2.5：兼容部分C字符串函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-6：总结"><span class="nav-text">2.2.6：总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3：SDS-API"><span class="nav-text">2.3：SDS API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4：重点回顾"><span class="nav-text">2.4：重点回顾</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第3章：链表"><span class="nav-text">第3章：链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1：链表和链表节点的实现"><span class="nav-text">3.1：链表和链表节点的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2：链表和链表节点的API"><span class="nav-text">3.2：链表和链表节点的API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第4章：字典"><span class="nav-text">第4章：字典</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1：字典的实现"><span class="nav-text">4.1：字典的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1：哈希表"><span class="nav-text">4.1.1：哈希表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2：哈希表节点"><span class="nav-text">4.1.2：哈希表节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3：字典"><span class="nav-text">4.1.3：字典</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2：哈希算法"><span class="nav-text">4.2：哈希算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3：解决键冲突"><span class="nav-text">4.3：解决键冲突</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4：Rehash"><span class="nav-text">4.4：Rehash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5：渐进式rehash"><span class="nav-text">4.5：渐进式rehash</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6：字典API"><span class="nav-text">4.6：字典API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第5章：跳跃表"><span class="nav-text">第5章：跳跃表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1：跳跃表的实现"><span class="nav-text">5.1：跳跃表的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1：跳跃表节点"><span class="nav-text">5.1.1：跳跃表节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2：跳跃表"><span class="nav-text">5.1.2：跳跃表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2：跳跃表API"><span class="nav-text">5.2：跳跃表API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第6章：整数集合"><span class="nav-text">第6章：整数集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1：整数集合的实现"><span class="nav-text">6.1：整数集合的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2：升级"><span class="nav-text">6.2：升级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3：升级的好处"><span class="nav-text">6.3：升级的好处</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1：提高灵活性"><span class="nav-text">6.3.1：提高灵活性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2：节约内存"><span class="nav-text">6.3.2：节约内存</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4：降级"><span class="nav-text">6.4：降级</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5：整数集合API"><span class="nav-text">6.5：整数集合API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第7章：压缩列表"><span class="nav-text">第7章：压缩列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1：压缩列表的构成"><span class="nav-text">7.1：压缩列表的构成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-压缩列表节点的构成"><span class="nav-text">7.2:压缩列表节点的构成</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-1：previous-entry-length"><span class="nav-text">7.2.1：previous_entry_length</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-2：encoding"><span class="nav-text">7.2.2：encoding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-2-3：content"><span class="nav-text">7.2.3：content</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3：连锁更新"><span class="nav-text">7.3：连锁更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4：压缩列表API"><span class="nav-text">7.4：压缩列表API</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第8章：对象"><span class="nav-text">第8章：对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1：对象的类型与编码"><span class="nav-text">8.1：对象的类型与编码</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-1-类型"><span class="nav-text">8.1.1:类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-1-2：编码和底层实现"><span class="nav-text">8.1.2：编码和底层实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2：字符串对象"><span class="nav-text">8.2：字符串对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-1：编码的转换"><span class="nav-text">8.2.1：编码的转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-2：字符串命令的实现"><span class="nav-text">8.2.2：字符串命令的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3：列表对象"><span class="nav-text">8.3：列表对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-1：编码转换"><span class="nav-text">8.3.1：编码转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-3-2：列表命令的实现"><span class="nav-text">8.3.2：列表命令的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4：哈希对象"><span class="nav-text">8.4：哈希对象</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy;  2018 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chungen</span>
</div>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
