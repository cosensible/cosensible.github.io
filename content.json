{"meta":{"title":"IamGroot","subtitle":"Blog of Chungen lchungen@qq.com","description":"所谓自由，不是随心所欲，而是自我主宰！","author":"Chungen","url":"http://chungen.coding.me","root":"/"},"pages":[{"title":"分类","date":"2019-08-24T10:04:32.000Z","updated":"2019-08-24T10:06:12.754Z","comments":false,"path":"categories/index.html","permalink":"http://chungen.coding.me/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-08-24T10:08:42.000Z","updated":"2019-08-24T10:09:20.306Z","comments":true,"path":"tags/index.html","permalink":"http://chungen.coding.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode-4 Median of Two Sorted Arrays","slug":"LeetCode-4","date":"2020-03-18T16:00:00.000Z","updated":"2020-03-19T10:49:38.824Z","comments":true,"path":"2020/03/19/LeetCode-4/","link":"","permalink":"http://chungen.coding.me/2020/03/19/LeetCode-4/","excerpt":"","text":"题目 There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty. Example 11234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 21234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 解题思路将两个数组分别分割为左右两部分，二者左边元素数量之和应该为总数量的一半。若左边元素都小于等于右边元素，即nums1中左边最大元素小于等于nums2中右边最小元素且nums2中左边最大元素小于等于nums1中右边最小元素，则中位数能够由这四个元素产生。若不满足，需要将nums1中的分割点向左或向右移动。 复杂度分析 时间复杂度：$O(min(m,n))$，最坏情况下需要移动半个数组 空间复杂度：$O(1)$ 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;class Solution_4 &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(), n = nums2.size(); if (m &gt; n) &#123; //移动短数组,降低移动次数 swap(nums1, nums2); swap(m, n); &#125; int l = m + n; //总共有多少个元素 int lmxi = m / 2 - 1, rmxi = m / 2; //nums1中 左边最大/右边最小 元素索引 int lmyi, rmyi; //nums2中 左边最大/右边最小 元素索引 int lmx, lmy, rmx, rmy; //nums1和nums2中 左边最大/右边最小 元素 //当nums1全部元素位于同一边,一定能得到中位数,但需要更新nums2的分割点 while (lmxi &gt;= -1 &amp;&amp; rmxi &lt;= m) &#123; //nums1和nums2中的左边元素数量之和应该为总数量的一半: l/2 //nums1中左边元素个数为rmxi,nums2中左边元素个数为l/2-rmxi,最后元素的索引等于数量减一 lmyi = l / 2 - rmxi - 1; rmyi = lmyi + 1; lmx = lmxi &lt; 0 ? INT_MIN : nums1[lmxi]; rmx = rmxi &gt;= m ? INT_MAX : nums1[rmxi]; lmy = lmyi &lt; 0 ? INT_MIN : nums2[lmyi]; rmy = rmyi &gt;= n ? INT_MAX : nums2[rmyi]; //nums1和nums2中的所有左边元素都不大于右边元素,且正好分成两半 //中位数由分界处的四个元素产生 if (lmx &lt;= rmy &amp;&amp; lmy &lt;= rmx) &#123; if (l % 2)return min(rmx, rmy); return (max(lmx, lmy) + min(rmx, rmy)) / 2.0; &#125; else if (lmx &gt; rmy) &#123; lmxi--; //nums1中左边最大元素大于nums2中右边最小元素,应该使其降低,即向左移动 &#125; else if (lmy &gt; rmx) &#123; lmxi++; //nums1中右边最小元素小于nums2中左边最大元素,应该使其增加,即向右移动 &#125; rmxi = lmxi + 1; &#125; &#125;&#125;;void test_4()&#123; vector&lt;int&gt; a = &#123; 1 &#125;, b = &#123; 2,3 &#125;; std::cout &lt;&lt; (Solution_4().findMedianSortedArrays(a, b) == 2) &lt;&lt; endl;&#125; 改进在移动分割点时，采用二分法确定位置，使算法的时间复杂度降低到：$O(log(min(m,n)))$ 1234567891011121314151617181920212223242526272829303132double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(), n = nums2.size(); if (m &gt; n) &#123; //选择短数组,降低二分次数 return findMedianSortedArrays(nums2, nums1); &#125; int l = m + n; //总共有多少个元素 int lmx, rmx, lmy, rmy; //nums1(nums2)中`左边最大和右边最小`元素 int px, py; //nums1和nums2的分割点, &gt;=px(py) 划为右边 int low = 0, high = m; //用于二分搜索 while (low &lt;= high) &#123; px = (low + high) / 2; py = l / 2 - px; lmx = px == 0 ? INT_MIN : nums1[px - 1]; rmx = px == m ? INT_MAX : nums1[px]; lmy = py == 0 ? INT_MIN : nums2[py - 1]; rmy = py == n ? INT_MAX : nums2[py]; //所有元素等分两半,且左边元素都不大于右边元素,则中位数由分界点的四个元素产生 if (lmx &lt;= rmy &amp;&amp; lmy &lt;= rmx) &#123; if (l % 2) return min(rmx, rmy); return (max(lmx, lmy) + min(rmx, rmy)) / 2.0; &#125; else if (lmx &gt; rmy) &#123; high = px - 1; //nums1中左边最大元素大于nums2中右边最小元素,应该使其减小,选择左边 &#125; else if (lmy &gt; rmx) &#123; low = px + 1; //nums1中右边最小元素小于nums2中左边最大元素,应该使其增大,选择右边 &#125; &#125;&#125;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://chungen.coding.me/categories/Leetcode/"},{"name":"算法","slug":"Leetcode/算法","permalink":"http://chungen.coding.me/categories/Leetcode/算法/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://chungen.coding.me/tags/Leetcode/"},{"name":"Hard","slug":"Hard","permalink":"http://chungen.coding.me/tags/Hard/"}]},{"title":"VMware 虚拟机通过 GNS3 路由器联网","slug":"虚拟机通过GNS3路由器联网","date":"2020-03-08T16:00:00.000Z","updated":"2020-03-19T04:28:09.752Z","comments":true,"path":"2020/03/09/虚拟机通过GNS3路由器联网/","link":"","permalink":"http://chungen.coding.me/2020/03/09/虚拟机通过GNS3路由器联网/","excerpt":"","text":"1. 说明本机为 PC 机，系统为 Windows 10，模拟器为 GNS3 2.2.3 一个无线网卡（192.168.0.108），用于 PC 连接互联网 一个有线网卡（192.168.0.104），用于关联 Cloud 节点 VMware 虚拟机，每台虚拟机配置一个网卡 2. Cloud 节点配置Cloud 节点与有线网卡关联，以连接互联网 3. 路由器联网 路由器接口 f0/0 连接 Cloud 节点关联的以太网卡 为接口 f0/0 配置 DHCP，动态获取 IP 地址 12345R1# conf tR1(config)# int f0/0R1(config-if)# ip address dhcpR1(config-if)# no shutdownR1(config-if)# end 得到地址：192.168.0.103 12R1# *Feb 25 10:21:06.959: %DHCP-6-ADDRESS_ASSIGN: Interface FastEthernet0/0 assigned DHCP address 192.168.0.103, mask 255.255.255.0, hostname R1 为路由器配置 DNS，用于解析域名 1234R1# conf tR1(config)# ip domain-lookupR1(config)# ip name-server 8.8.8.8R1(config)# end 测试路由器是否连接互联网，成功 12345678R1# ping www.baidu.comTranslating &quot;www.baidu.com&quot;...domain server (192.168.1.1) [OK]Type escape sequence to abort.Sending 5, 100-byte ICMP Echos to 14.215.177.39, timeout is 2 seconds:!!!!!Success rate is 100 percent (5/5), round-trip min/avg/max = 12/27/32 ms 4. 内部网络配置内部网络包含两台在同一网段的虚拟机，IP 地址分别为：192.168.1.108、192.168.1.109 用一台交换机将它们和路由器接口 f0/1 连接。 4.1 虚拟机配置4.1.1 导入 VM 虚拟机 在 VMware 中创建两台虚拟机，分别为 Ubuntu 16.04 和 CentOS 7 在 GNS3 中导入两台虚拟机，注意勾选：Allow GNS3 to override non custom VMware adapter 在 VMware 中点击 “编辑 - 虚拟网络编辑器”，添加供 GNS3 使用的网卡，注意选择仅主机模式并禁用DHCP。或者在 GNS3 中点击 “Preference - VMware - Advanced local settings - Configure” 选项，调用 gns3vmnet 自动完成。 （由 GNS3 启动虚拟机后，会为虚拟机自动配置网卡） GNS3 will randomly select an available Host-only VMnet to bridge the VMware virtual machine into the GNS3 topology. VMnet 0 (bridged), VMnet 1 (host-only), and VMnet 8 (NAT) are available in VMware by default, but will not be used by GNS3 for this purpose! It is important that any new Host-Only VMnet created for GNS3 to use have the default DHCP for it disabled! 4.1.2 配置 IP 地址 IP：192.168.1.108 (192.168.1.109) mask：255.255.255.0 gateway：192.168.1.1 DNS：8.8.8.8 两台虚拟机的网关就是路由器接口 f0/1，为其配置 IP 地址： 12345R1# conf tR1(config)# int f0/1R1(config-if)# ip address 192.168.1.1 255.255.255.0R1(config-if)# no shutdownR1(config-if)# end 4.1.3 测试虚拟机联网12345678910$ ping 192.168.0.103PING 192.168.0.103 (192.168.0.103) 56(84) bytes of data.64 bytes from 192.168.0.103: icmp_seq=1 ttl=255 time=2.64 ms64 bytes from 192.168.0.103: icmp_seq=2 ttl=255 time=3.80 ms$ ping 192.168.0.108PING 192.168.0.108 (192.168.0.108) 56(84) bytes of data.^C--- 192.168.0.108 ping statistics ---12 packets transmitted, 0 received, 100% packet loss, time 11272ms 能 ping 通路由器另一端，但 ping 不通与路由器在同一网段的无线网卡，不能连接互联网，需要配置 NAT。 4.2 NAT 配置4.2.1 内外端口定义123456R1# conf tR1(config)# int f0/0R1(config-if)# ip nat outsideR1(config-if)# int f0/1R1(config-if)# ip nat insideR1(config-if)# exit 4.2.2 NAT 配置方式可以选择：静态 NAT 配置、端口复用、动态 NAT 配置。 1. 静态 NAT 配置：ip nat inside source static 内部私有IP地址 公网地址 12R1(config)# ip nat inside source static 192.168.1.108 192.168.0.118R1(config)# ip nat inside source static 192.168.1.109 192.168.0.119 2. 端口复用 1234// 建立允许内网IP网段进行NAT转换的ACLaccess-list ACL编号 permit 内网IP网段 通配符掩码// 建立端口复用NATip nat inside source list ACL编号 interface 外网接口 overload 12R1(config)#access-list 1 permit 192.168.1.0 0.0.0.255R1(config)#ip nat inside source list 1 interface f0/0 overload 3. 动态 NAT 配置 123456// 建立允许内网IP网段进行NAT转换的ACLaccess-list ACL编号 permit 内网IP网段 通配符掩码// 建立公网IP地址池ip nat pool 地址池名称 起始公网地址 结束公网地址 netmask 子网掩码// 建立动态NATip nat inside source list ACL编号 pool 公网地址池名称 123R1(config)#access-list 1 permit 192.168.1.0 0.0.0.255R1(config)#ip nat pool gen 192.168.0.120 192.168.0.130 netmask 255.255.255.0R1(config)#ip nat inside source list 1 pool gen 在虚拟机上测试互联网连接，成功 1234$ ping www.baidu.comPING www.wshifen.com (104.193.88.123) 56(84) bytes of data.64 bytes from 104.193.88.123 (104.193.88.123): icmp_seq=1 ttl=50 time=214 ms64 bytes from 104.193.88.123 (104.193.88.123): icmp_seq=3 ttl=50 time=208 ms 5. 保存配置1R1# write memory","categories":[{"name":"网络","slug":"网络","permalink":"http://chungen.coding.me/categories/网络/"}],"tags":[{"name":"GNS3","slug":"GNS3","permalink":"http://chungen.coding.me/tags/GNS3/"}]},{"title":"VIM配置YouCompleteMe","slug":"VIM配置YouCompleteMe","date":"2019-08-14T16:00:00.000Z","updated":"2019-08-24T10:37:09.468Z","comments":true,"path":"2019/08/15/VIM配置YouCompleteMe/","link":"","permalink":"http://chungen.coding.me/2019/08/15/VIM配置YouCompleteMe/","excerpt":"","text":"条件 Vim版本大于等于7.4，并且支持python2或python3。 编译YouCompleteMe需要cmake，且依赖python文件，可用以下命令安装: 1sudo apt install build-essential cmake python3-dev clang是一个面向C族语言的轻量级编译器，YouCompleteMe插件依赖clang实现对C族语言的语义补全。 步骤 下载YouCompleteMe源码： 1git clone https://github.com/Valloric/YouCompleteMe.git ~/.vim/plugged/ 下载源码后，在源码目录运行： 1git submodule update --init --recursive 编译YouCompleteMe。YouCompleteMe需要手工编译出库文件ycm_core.so(以及依赖的libclang.so)才能使用。 在YouCompleteMe目录下执行./install.py --clang-completer即可编译出具有C族语言语义补全功能的YouCompleteMe插件。 其他选项还有：c#(--cs-)、go(--go-)、JS(--ts-)、Java(--java-)、Rust(--rust-)。 以上选项都必须满足相应依赖；--all则会编译以上所有满足依赖的选项。 必须要在.vimrc的插件列表中引用该插件。 .vimrc文件中的ycm配置项的python解释器应该与编译YouCompleteMe时所用的python版本一致。","categories":[{"name":"教程","slug":"教程","permalink":"http://chungen.coding.me/categories/教程/"},{"name":"linux","slug":"教程/linux","permalink":"http://chungen.coding.me/categories/教程/linux/"}],"tags":[{"name":"VIM","slug":"VIM","permalink":"http://chungen.coding.me/tags/VIM/"}]},{"title":"Redis设计与实现","slug":"Redis设计与实现","date":"2019-01-24T16:00:00.000Z","updated":"2019-08-24T09:32:36.887Z","comments":true,"path":"2019/01/25/Redis设计与实现/","link":"","permalink":"http://chungen.coding.me/2019/01/25/Redis设计与实现/","excerpt":"","text":"[TOC] Redis 设计与实现第1章：概览第一部分：数据结构与对象 redis数据库里面的每个键值对都由对象组成，其中： 键总是一个字符串对象 值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象 第二部分：单机数据库的实现 第9章：数据库。介绍数据库的实现原理，说明了： 服务器保存键值对的方法 服务器保存键值对过期时间的方法 服务器自动删除过期键值对的方法 第10章：RDB持久化和第11章：AOF持久化。分别介绍Redis的两种持久化方式，说明了： 服务器根据数据库生成持久化文件的方法，服务器根据持久化文件还原数据库的方法 BGSAVE命令和BGREWRITEAOF命令的实现原理 第12章：事件。介绍文件事件和时间事件 文件事件：用于应答（accept）客户端的连接请求，接收客户端的命令请求，向客户端返回命令回复 时间事件：执行redis.c/serverCron函数，该函数保持Redis服务器正常运行，触发定时操作 第13章：客户端。介绍服务器维护和管理客户端状态的方法，客户端状态的属性，客户端的输入和输出缓冲区，服务器创建和销毁客户端状态的条件 第14章：服务器。介绍单机服务器的运作机制，服务器处理命令请求的步骤，serverCron函数，服务器初始化过程 第三部分：多机数据库的实现 第15章：复制。介绍Redis主从复制 第16章：Sentinel。说明Sentinel监视服务器的方法，判断服务器是否下线的方法，对下线服务器进行故障转移的方法。 第17章：集群。说明节点的构建方法，节点处理命令请求的方法，转发错误的实现，各节点通信的方法 第四部分：独立功能的实现 第18章：发布与订阅。PUBLISH、SUBSCRIBE、PUBSUB等命令 第19章：事务。MULTI、EXEC、WATCH等命令，说明Redis的事务对ACID性质的支持程度 第20章：Lua脚本。EVAL、EVALSHA、SCRIPT LOAD等命令，解释Redis服务器如何执行和管理用户传入的Lua脚本，服务器构建Lua环境的过程，主从服务器之间复制Lua脚本的方法 第21章：排序。SORT命令和命令选项（DESC、ALPHA、GET）以及不同选项执行的顺序 第22章：二进制位数组。GETBIT、SETBIT、BITCOUNT、BITOP命令 第23章：慢查询日志。SLOWLOG GET、SLOWLOG LEN、SLOWLOG RESET命令 第24章：监视器。如何将客户端变为监视器（monitor），服务器如何向监视器发送命令信息 第一部分：数据结构与对象第2章：简单动态字符串（SDS）Redis没有直接使用C字符串，在Redis里C字符串只会作为字符串字面量，用在无须修改字符串值的地方。当Redis需要一个可以被修改的字符串值时会使用SDS。SDS不仅可以用来保存字符串值，还能被用作缓冲区：AOF缓冲区、客户端状态中的输入缓冲区。 2.1：SDS的定义每个sds.h/sdshdr结构表示一个SDS值： 1234567891011struct sdshdr &#123; // 记录buf数组中已使用字节的数量 // 等于SDS所保存字符串的长度 int len; // 记录buf数组中未使用字节的数量 int free; // 字节数组，用于保存字符串 char buf[];&#125;; SDS和C字符串一样，以空字符结尾。保存空字符的1字节不算在len属性里，SDS自动为空字符分配额外的1字节且将空字符添加到字符串末尾。所以这个空字符对用户完全透明。以空字符结尾的好处是SDS可以重用C字符串函数库里面的一部分函数。 2.2：SDS与C字符串的区别2.2.1：常数复杂度获取字符串长度C字符串不记录自身的长度信息，所以为获取其长度需要遍历一遍。 获取一个SDS的长度只要常数时间，设置和更新SDS长度的工作由SDS的API在执行时自动完成。 2.2.2：杜绝缓冲区溢出C字符串假定用户已经分配足够多的内存，若该假定不成立，就会产生缓冲区溢出。 当SDS API需要修改SDS时，API会先检查SDS的空间是否满足，若不满足，API会自动扩展空间，然后执行修改。无须手动修改SDS的空间大小。 2.2.3：减少修改字符串带来的内存重分配次数每次增长或缩短一个C字符串，程序都要对其数组进行一次内存重分配。 SDS通过未使用空间实现了空间预分配和惰性空间释放两种优化策略。 空间预分配：当需要对SDS进行空间扩展时，程序不仅分配必须的空间，而且还会分配额外的未使用空间。额外空间数量由以下公式决定： 若SDS的长度在修改后小于1MB，分配len大小的未使用空间，此时len=free。否则，分配1MB大小。 惰性空间释放：当SDS的API需要缩短字符串时，程序不立即释放其空间，而是使用free属性记录字节数量，等到将来使用。 此外，SDS提供了API让我们在需要时真正地释放SDS的未使用空间。 2.2.4：二进制安全C字符串必须符合某种编码，且除了字符串末尾外，字符串里面不能包含空字符。这些限制使其只能保存文本数据，而不能保存图片、音频、视频、压缩文件等二进制数据。 所有SDS API都会以处理二进制的方式来处理buf数组（字节数组）里面的数据。SDS用len的值而不是空字符来判断字符串是否结束。 2.2.5：兼容部分C字符串函数SDS遵循C字符串以空字符结尾的惯例，这使得保存文本数据的SDS可以重用一部分库定义的函数。 2.2.6：总结 C字符串 SDS 获取字符串长度的复杂度为O(N) 获取字符串长度的复杂度为O(1) API不安全，可能会造成缓冲区溢出 API安全，不会造成缓冲区溢出 修改字符串长度N次必然执行N次内存重分配 修改字符串长度N次最多执行N次内存重分配 只能保存文本数据 可以保存文本数据或二进制数据 可以使用库中的所有函数 可以使用部分库中的函数 2.3：SDS API 函数 作用 时间复杂度 sdsnew 创建包含给定C字符串的SDS O(N)，N为字符串长度 sdsempty 创建不包含任何内容的空SDS O(1) sdsfree 释放给定的SDS O(N)，N为被释放SDS的长度 sdslen 返回SDS已使用空间字节数 len属性，O(1) sdsavail 返回SDS未使用空间字节数 free属性，O(1) sdsdup 创建一个给定SDS的副本（copy） O(N) sdsclear 清空SDS保存的字符串内容 惰性空间释放，O(1) sdscat 将给定C字符串拼接到SDS字符串末尾 O(N)，N为给定C字符串的长度 sdscatsds 将给定SDS字符串拼接到另一个SDS末尾 O(N)，N为给定SDS字符串的长度 sdscopy 将给定C字符串复制到SDS里，覆盖SDS原有字符串 O(N)，N为给定C字符串的长度 sdsgrowzero 用空字符将SDS扩展至给定长度 O(N)，N为新增字节数 sdsrange 保留SDS给定区间内数据，其他数据被覆盖或清除 O(N)，N为被保留数据字节数 sdstrim 接受一个SDS和一个C字符串作为参数，从SDS左右两端分别移除所有在C字符串中出现过的字符 O(M*N)，M为SDS长度，N为C字符串长度 sdscmp 比较两个SDS字符串是否相同 O(N)，N为较短SDS的长度 2.4：重点回顾Redis只会使用C字符串作为字面量，大多情况下，Redis使用SDS表示字符串。 SDS具有如下优点： 常数复杂度获取字符串长度 杜绝缓冲区溢出 减少修改字符串长度时所需的内存重分配次数 二进制安全 兼容部分C字符串库函数 第3章：链表链表用在：列表键实现、发布与订阅、慢查询、监视器、保存客户端状态信息、构建客户端输出缓冲区等 3.1：链表和链表节点的实现链表节点adlist.h/listNode 12345678typedef struct listNode&#123; // 前置节点 struct listNode *prev; // 后置节点 struct listNode *next; // 节点的值 void *value;&#125;listNode; 使用adlist.h/list来持有链表，使链表操作更方便 1234567891011121314typedef struct list&#123; // 表头节点 listNode *head; // 表尾节点 listNode *tail; // 链表包含的节点数 unsigned long len; // 节点值复制函数 void *(*dup)(void *ptr); // 节点值释放函数 void (*free)(void *ptr); // 节点值对比函数 int (*match)(void *ptr,void *key);&#125;list; dup、free、match成员用于实现多态链表所需的类型特定函数。 双端链表迭代器结构 123456typedef struct listIter &#123; // 当前迭代到的节点 listNode *next; // 迭代的方向 int direction;&#125; listIter; Redis链表实现特性： 双端、无环（表头节点的prev和表尾节点的tail都指向NULL，对链表的访问以NULL为终点） 带表头指针和表尾指针（list结构的head指针和tail指针） 带链表长度计数器（list结构的len属性） 多态：链表节点使用void*指针保存节点值，且可以通过list结构的dup、free、match属性为节点值设置类型特定函数，所以链表可以保存各种类型的值。 3.2：链表和链表节点的API 函数 作用 listSetDupMethod 将给定函数设置为链表的节点值复制函数 listGetDupMethod 返回链表当前正在使用的节点值复制函数 listSetFreeMethod 将给定函数设置为链表的节点值释放函数 listGetFree 返回链表当前正在使用的节点值释放函数 listSetMatchMethod 将给定函数设置为链表的节点值对比函数 listGetMatchMethod 返回链表当前正在使用的节点值对比函数 listLength 返回链表长度 listFirst 返回链表表头节点 listLast 返回链表表尾节点 listPrevNode 返回给定节点的前置节点 listNextNode 返回给定节点的后置节点 listNodeValue 返回给定节点当前保存的值 listCreate 创建一个不包含任何节点的新链表 listAddNodeHead 将一个新节点添加到链表表头 listAddNodeTail 将一个新节点添加到链表表尾 listInsertNode 将一个新节点添加到给定节点之前或之后 listSearchKey 查找并返回链表中包含给定值的节点 listIndex 返回链表在给定索引上的节点 listDelNode 从链表中删除给定节点 listRotate 将链表表尾节点弹出并插入到链表表头 listDup 复制一个给定链表的副本 listRelease 释放给定链表以及链表中的所有节点 第4章：字典Redis数据库使用字典作为底层实现，对数据库的增删改查都基于字典的操作。 字典也是哈希键的底层实现之一。 4.1：字典的实现Redis字典使用哈希表作为底层实现，一个哈希表有多个哈希表节点，每个哈希表节点保存字典中的一个键值对。 4.1.1：哈希表dict.h/dictht结构，其中table是一个数组，保存指向dict.h/dictEntry结构的指针，每个dictEntry保存一个键值对。 1234567891011typedef struct dictht&#123; // 哈希表数组 dictEntry **table; // 哈希表大小，即table数组大小 unsigned long size; // 哈希表大小掩码，用于计算索引值 // 总是等于 size-1 unsigned long sizemask; // 该哈希表已有节点数 unsigned long used;&#125; dictht; 4.1.2：哈希表节点dictEntry结构，保存键值对 123456789101112typedef struct dictEntry&#123; // 键 viod *key; // 值，可以是一个指针、uint64_t整数或int64_t整数 union&#123; void *val; uint64_t u64; int64_t s64; &#125;v; // 指向下个哈希表节点，链地址法解决哈希冲突 struct dictEntry *next;&#125;dictEntry; 4.1.3：字典dict.h/dict结构 1234567891011typedef struct dict&#123; // 类型特定函数 dictType *type; // 私有数据 void *privdata; // 哈希表 dictht ht[2]; // rehash索引 // 当rehash不在进行时，值为-1 int rehashidx;&#125;dict; type和privdata属性针对不同类型的键值对，为创建多态字典设置： type属性为指向dictType结构的指针，每个dictType保存一簇用于操作特定类型键值对的函数。 privdata属性保存需要传给类型特定函数的可选参数 1234567891011121314typedef struct dictType&#123; // 计算哈希值的函数 unsigned int (*hashFunction)(const void *key); // 复制键的函数 void *(*keyDup)(void *privdata,const void *key); // 复制值的函数 void *(*valDup)(void *privdata,const void *obj); // 对比键的函数 int (*keyCompare)(void *privdata,const void *key1,const void *key2); // 销毁键的函数 void (*keyDestructor)(void *privdata,void *key); // 销毁值的函数 void (*valDestructor)(void *privdata,void *obj);&#125;dictType; ht属性是一个包含两个项的数组，其中每项是一个dictht哈希表，ht[1]只会在对ht[0]进行rehash时使用。 rehashidx属性记录目前rehash的进度，若没有进行rehash，其值为-1。 4.2：哈希算法当要将一个新的键值对添加到字典里时，程序先根据键计算哈希值和索引值，然后根据索引值将包含新键值对的哈希表节点放到哈希表数组中。 12345// 使用字典设置的哈希函数，计算键key的哈希值hash=dict-&gt;type-&gt;hashFunction(key);// 使用哈希表的sizemask和哈希值，计算索引值// 根据情况不同，ht[x]可以是ht[0]或ht[1]index=hash &amp; dict-&gt;ht[x].sizemask; 当字典用于数据库或哈希键底层实现时，Redis使用MurmurHash2算法计算键的哈希值。该算法优点在于，即使输入的键是有规律的，算法仍有很好的随机分布性，且算法的计算速度非常快。 4.3：解决键冲突Redis的哈希表使用链地址法来解决键冲突。 因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度，程序总将新节点添加到链表表头。 4.4：Rehash随着操作不断执行，哈希表中的键值对会逐渐增多或减少，为了让哈希表的负载因子维持在合理范围，程序需要对哈希表大小进行扩展或收缩。rehash(重散列)步骤如下： 为字典的ht[1]哈希表分配空间，大小取决于执行的操作以及ht[0]当前包含的键值对数量（ht[0].used） 若执行扩展操作，ht[1]的大小为第一个大于等于ht[0].used2的*$2^n$； 若执行收缩操作，ht[1]的大小为第一个大于等于ht[0].used的$2^n$。 将ht[0]中的所有键值对rehash到ht[1]上：rehash指重新计算键的哈希值和索引值，然后将键值对放到ht[1]的指定位置。 当ht[0]包含的所有键值对都迁移到了ht[1]后（ht[0]变为空表），释放ht[0]，将ht[1]设为ht[0]，最后为ht[1]分配一个空白哈希表，为下一次rehash做准备。 哈希表的扩展与收缩 当以下条件任意一个被满足时，程序会自动对哈希表执行扩展操作： 服务器目前没执行BGSAVE或BGREWRITEAOF命令，且哈希表负载因子大于等于1。 服务器正在执行BGSAVE或BGREWRITEAOF命令，且哈希表负载因子大于等于5。 哈希表负载因子=哈希表已保存节点数量/哈希表大小：load_factor=ht[0].used/ht[0].size 在执行BGSAVE或BGREWRITEAOF命令时，需要创建当前服务器进程的子进程，且大多OS都采用写时复制技术优化子进程效率。所以在子进程存在期间，服务器会提高执行扩展操作的负载因子，从而尽可能避免在子进程存在期间进行哈希表扩展，避免不必要的内存写入操作，最大限度节约内存（写内存时会复制） 当负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。 4.5：渐进式rehash当扩展或收缩哈希表时，rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。原因在于如果哈希表保存的键值对数量很庞大时，要一次性将其rehash的话，可能会导致服务器在一段时间内停止服务。以下是哈希表渐进式rehash的步骤： 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表 在字典中维持一个索引计数器变量rehashidx，并将其设为0，表示rehash工作开始 在rehash期间，每次对字典执行增删改查操作时，程序除了执行该指定操作，还会顺便将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，然后将rehashidx加一。 随着对字典不断操作，最终ht[0]所有键值对都会被rehash到ht[1]，这时程序将rehashidx设为-1，表示rehash操作完成。 渐进式rehash将rehash键值对所需的计算工作均摊到对字典的每个增删改查操作上，避免了集中式rehash带来的庞大计算量。 渐进式rehash执行期间的哈希表操作 因为在渐进式rehash期间，字典会同时使用ht[0]和ht[1]，所以在此期间，字典的删除、更新、查找操作会在两个哈希表上进行。例如，查找会先在ht[0]查找，没找到会在ht[1]继续查找。 另外，在渐进式rehash期间，新添加到字典的键值对会一律保存到ht[1]中，ht[0]上不进行任何添加操作，保证ht[0]包含的键值对数量不断减少，并随着rehash操作最终变为空表。 4.6：字典API 函数 作用 dictCreate 创建新字典O(1) dictAdd 添加给定键值对O(1) dictReplace 添加给定键值对，如果键已经存在，替换其值O(1) dictFetchValue 返回给定键的值O(1) dictGetRandomKey 随机返回一个键值对O(1) dictDelete 删除给定键的键值对O(1) dictRelease 释放字典以及字典中的所有键值对O(N) 第5章：跳跃表有序数据结构，通过在每个节点中维持多个指向其他节点的指针来达到快速访问节点的目的。支持平均$O(logN)$、最坏$O(N)$复杂度的节点查找，还能通过顺序性操作来批量处理节点。Redis使用跳跃表作为有序集合键的底层实现之一。 Redis只在两个地方用到了跳跃表：实现有序集合键、在集群节点中用作内部数据结构 5.1：跳跃表的实现Redis跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义，前者表示跳跃表节点，后者保存跳跃表相关信息（节点数量、表头节点、表尾节点等） 5.1.1：跳跃表节点123456789101112131415typedef struct zskiplistNode&#123; // 后退指针 struct zskiplistNode *backward; // 分值 double score; // 成员对象 robj *obj; // 层 struct zskiplistLevel&#123; // 前进指针 struct zskiplistNode *forward; // 跨度 unsigned int span; &#125;level[];&#125;zskiplistNode; 层：跳跃表节点的level数组可包含多个元素，每个元素包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度。每次创建一个新的跳跃表节点时，都根据幂次定律（越大的数出现的概率越小）随机生成一个介于1到32之间的值作为level数组的大小，该大小为层的“高度”。 前进指针：每个层包含一个指向表尾方向的前进指针。 跨度：用于记录两个节点间的距离。指向NULL的所有前进指针跨度为0。跨度用来计算排位：在查找某个节点时，将沿途经过的层的跨度累计便得到目标节点在跳跃表中的排位 后退指针：用于反向访问跳跃表，只有一个。 分值和成员：分值为double类型，所有节点按分值从小到大排序；成员对象是一个指针，指向SDS对象。在同一跳跃表中，各节点保存的成员对象必须唯一，而分值可以相等：分值相等则按成员对象字典序排序 只会用到表头节点的各个层，其他属性不会被用到。 5.1.2：跳跃表12345678typedef struct zskiplist&#123; // 表头节点和表尾节点 struct zskiplistNode *header,*tail; // 表中节点数量（不含表头节点） unsigned long length; // 表中层数最大节点的层数（不含表头节点） int level;&#125;zskiplist; 5.2：跳跃表API 函数 作用 时间复杂度 zslCreate 创建跳跃表 O(1) zslFree 释放跳跃表及其所有节点 O(N) zslInsert 将包含给定成员和分值的节点加入跳跃表 平均O(logN)，最坏O(N) zslDelete 删除包含给定成员和分值的节点 平均O(logN)，最坏O(N) zslGetRank 返回给定节点的排位 平均O(logN)，最坏O(N) zslGetElementByRank 返回给定排位上的节点 平均O(logN)，最坏O(N) zslIsInRange 给定一个范围，判断其是否包含在跳跃表的分值范围内 O(1)，通过表头节点和表尾节点 zslFirstInRange 给定一个范围，返回跳跃表中第一个分值在范围内的节点 平均O(logN)，最坏O(N) zslLastInRange 给定一个范围，返回跳跃表中最后一个分值在范围内的节点 平均O(logN)，最坏O(N) zslDeleteRangeByScore 给定一个范围，删除跳跃表中所有分值在范围内的节点 O(N)，N为被删节点数 zslDeleteRangeByRank 给定一个范围，删除跳跃表中所有排位在范围内的节点 O(N)，N为被删节点数 第6章：整数集合当一个集合只包含整数值元素，且元素数量不多时，Redis使用整数集合作为集合键的底层实现。 6.1：整数集合的实现整数集合可以保存int16_t、int32_t、或int64_t的整数值，并且会保证集合中无重复元素。 intset.h/intset结构： 12345678typedef struct intset&#123; // 编码方式 uint32_t encoding; // 集合包含的元素数量 uint32_t length; // 保存元素的数组 int8_t contents[];&#125;intset; 整数集合的每个元素是contents数组的数据项，各项在数组中从小到大排列，且数组中无重复项。 虽然intset结构将contents声明为int8_t，但该数组并不保存任何int8_t类型的值，其真正类型取决于encoding的值：INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64。 6.2：升级每当将一个新元素添加到整数集合中，且新元素类型比整数集合当前类型要长时，整数集合要进行升级，然后才能添加新元素。步骤如下： 根据新元素类型，扩展整数集合底层数组，并为新元素分配空间。（集合元素+新元素） 将底层数组当前所有元素转换成与新元素相同的类型，并将其放在正确的比特位上，且维持有序性。 将新元素添加进底层数组中，同时更改encoding属性和length属性。 升级后新元素摆放位置 引发升级的新元素的长度总比整数集合所有元素的长度都大，所以新元素的值要么大于所有元素，要么小于所有元素：大于则新元素放在底层数组末尾，小于则放在开头。 6.3：升级的好处6.3.1：提高灵活性因为C语言是静态类型语言，为了避免类型错误，不会将两种不同类型的数据放在同一个数据结构中。但是整数集合可以通过自动升级底层数组来存放新元素，所以能随意添加int16_t、int32_t、int64_t类型的数据。 6.3.2：节约内存整数集合能添加三种不同类型的值，且能确保升级操作只会在有需要时进行，尽量节省内存。 6.4：降级整数集合不支持降级操作，一旦升级，编码会一直保持升级后的状态。 6.5：整数集合API 函数 作用 时间复杂度 intsetNew 创建整数集合 O(1) intsetAdd 添加给定元素到整数集合 可能会升级，O(N) intsetRemove 移除给定元素 O(N) intsetFind 查找给定元素 排好序了，O(logN) intsetRandom 随机返回一个元素 O(1) intsetGet 返回给定索引上的元素 O(1) intsetLen 返回整数集合元素个数 O(1) intsetBlobLen 返回整数集合占用字节数 O(1) 第7章：压缩列表压缩列表（ziplist）是列表键和哈希键的底层实现之一： 当一个列表键只包含少量列表项，且每个列表项是小整数值或长度较短的字符串时 当一个哈希键只包含少量键值对，且每个键值对的键和值是小整数值或长度较短的字符串时 7.1：压缩列表的构成压缩列表是redis为了节约内存开发的，是由一系列特殊编码的连续内存块组成的顺序型结构。一个压缩列表可以包含任意个节点（entry），每个节点保存一个字节数组或一个整数值。 压缩列表各组成部分如下： 属性 类型 长度 用途 zlbytes uint32_t 4字节 记录整个压缩列表占用的字节数：在内存重分配或计算zlend时使用 zltail uint32_t 4字节 记录表尾节点距离起始地址的字节数 zllen uint16_t 2字节 记录压缩列表的节点数：当该值等于UINT16_MAX(65535)时，真实数量需要遍历整个列表得到；小于65535时可用 entryX 列表节点 不定 压缩列表节点的长度由节点保存的内容决定 zlend uint8_t 1字节 特殊值0xFF(十进制255)，用于标记列表末端 7.2:压缩列表节点的构成每个压缩列表节点可以保存一个字节数组或一个整数值： 字节数组的长度可以是：小于等于63($2^6-1$)、16383($2^{14}-1$)或($2^{32}-1$)字节。 整数值长度可以是：4位(0-12之间的无符号整数)、1字节或3字节有符号整数、int16_t、int32_t、int64_t类型的整数。 每个压缩列表节点都由previous_entry_length、encoding、content三部分组成。 7.2.1：previous_entry_length记录前一个节点包含的字节数，该属性长度可以是1字节或5字节： 若前一节点字节数小于254，则该属性为1字节。 否则，该属性为5字节：第一个字节为0xEE(254)，之后四字节用于保存前一节点长度。 程序可以通过指针运算，根据当前节点的起始地址计算前一个节点的起始地址，且可以一直回溯到表头节点。 7.2.2：encodingencoding属性记录节点的content属性所保存数据的类型和长度： 字节数组编码： 编码 编码长度 content属性保存的值 00bbbbbb 1字节 长度小于等于($2^6-1$)字节的字节数组 01bbbbbb xxxxxxxx 2字节 长度小于等于($2^{14}-1$)字节的字节数组 10____ aaaaaaaa bbbbbbbb cccccccc dddddddd 5字节 长度小于等于($2^{32}-1$)字节的字节数组 整数编码： 编码 编码长度 content属性保存的值 11000000 1字节 int16_t类型的整数 11010000 1字节 int32_t类型的整数 11100000 1字节 int64_t类型的整数 11110000 1字节 3字节有符号整数 11111110 1字节 1字节有符号整数 1111xxxx 1字节 使用这一编码的节点无content属性，xxxx四位保存(0,12)之间的值 7.2.3：content节点的content属性保存节点的值，节点值可以是一个字节数组或整数，其类型和长度由节点的encoding属性决定。 7.3：连锁更新每个节点的previous_entry_length属性都记录了前一个节点的长度，如果前一节点长度小于254字节，该属性需要一字节，否则需要5字节。当在压缩列表中插入或删除节点时，可能会对压缩列表节点的previous_entry_length属性执行空间重分配操作（由于内存连续，每次内存重分配需要复杂度O(N)），从而引起后面一系列节点的空间重分配操作，Redis将这种特殊情况下产生的连续多次空间扩展操作称为“连锁更新”。连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，每次内存重分配最坏复杂度为O(N)，所以连锁更新最坏复杂度为O(N方)。 尽管连锁更新复杂度较高，但它造成性能问题的几率很低： 压缩列表中要恰好有多个连续的、长度介于250字节到253字节之间的节点才有可能引发连锁更新。 即使出现连锁更新，只要数量不多，就不会对性能造成影响。 基于以上原因，ziplistPush等命令的平均复杂度仅为O(N)，实际中可以放心使用 7.4：压缩列表API 函数 作用 复杂度 ziplistNew 创建压缩列表 O(1) ziplistPush 创建包含给定值的新节点，并将节点添加到表头或表尾 平均O(N)，最坏O(N方) ziplistInsert 将包含给定值的新节点插入到给定地址 平均O(N)，最坏O(N方) ziplistIndex 返回压缩列表给定索引上的节点 O(N) ziplistFind 查找并返回包含给定值的节点 节点值可能为字节数组，需要O(N)复杂度来判断节点值是否和给定值相等，所以查找整个列表的复杂度为O(N方) ziplistNext 返回给定节点的下一个节点 O(1)，每个节点占用字节数可以计算得到 ziplistPrev 返回给定节点的前一个节点 O(1) ziplistGet 返回给定节点保存的值 O(1) ziplistDelete 删除压缩列表中给定地址上的节点 平均O(N)，最坏O(N方) ziplistDeleteRange 删除压缩列表在给定索引上的连续多个节点 平均O(N)，最坏O(N方) ziplistBlobLen 返回压缩列表占用的内存字节数 O(1) ziplistLen 返回压缩列表包含的节点数 节点数小于65535时O(1)，否则为O(N) 第8章：对象在前面各章节中，介绍了Redis用到的所有数据结构：简单动态字符串(SDS)、双端链表、字典、压缩列表、整数集合、跳跃表。Redis基于这些数据结构创建了一个对象系统，包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象。Redis可以在执行命令前根据对象类型判断一个对象是否能执行给定命令；可以针对不同使用场景为对象设置多种数据结构的实现，优化对象使用效率。 Redis对象系统实现了基于引用计数的内存回收机制，当程序不再使用某对象时，其内存会被自动释放；Redis还实现了基于引用计数的对象共享机制，可以通过让多个数据库键共享同一个对象来节约内存；Redis对象带有访问时间记录信息，可用于计算数据库键的空转时间，在服务器启用maxmemory功能时，空转时长大的键会优先被删除。 8.1：对象的类型与编码Redis使用对象来表示数据库中的键和值，每当创建一个键值对，至少会创建两个对象，一个用作键（键对象），一个用作值（值对象）。每个对象由redisObject结构表示，其中和保存数据有关的三个属性如下： 123456789typedef struct redisObject&#123; // 类型 unsigned type:4; // 编码 unsigned encoding:4; // 指向底层数据结构的指针 void *ptr; // ...&#125;robj; 8.1.1:类型类型可以是：REDIS_STRING、REDIS_LIST、REDIS_HASH、REDIS_SET、REDIS_ZSET 键总是一个字符串对象，而值可以是五种对象的其中一种，因此当称呼一个键为“列表键”时，指“该数据库键所对应的值为列表对象”。TYPE命令返回数据库键所对应的值对象的类型。 8.1.2：编码和底层实现对象的ptr指针指向对象的底层数据结构，这些数据结构由encoding属性决定。encoding属性的值可以是： 编码常量 编码对应的底层数据结构 REDIS_ENCODING_INT long类型整数 REDIS_ENCODING_EMBSTR embstr编码的简单动态字符串 REDIS_ENCODING_RAW 简单动态字符串 REDIS_ENCODING_HT 字典 REDIS_ENCODING_LINKEDLIST 双端链表 REDIS_ENCODING_ZIPLIST 压缩列表 REDIS_ENCODING_INTSET 整数集合 REDIS_ENCODING_SKIPLIST 跳跃表和字典 每种对象类型都至少使用了两种编码，即至少有两种底层实现： 类型 编码 对象 REDIS_STRING REDIS_ENCODING_INT 使用整数值实现的字符串对象 REDIS_STRING REDIS_ENCODING_EMBSTR 使用embstr编码的SDS实现的字符串对象 REDIS_STRING REDIS_ENCODING_RAW 使用简单动态字符串(SDS)实现的字符串对象 REDIS_LIST REDIS_ENCODING_ZIPLIST 使用压缩列表实现的列表对象 REDIS_LIST REDIS_ENCODING_LINKEDLIST 使用双端链表实现的列表对象 REDIS_HASH REDIS_ENCODING_ZIPLIST 使用压缩列表实现的哈希对象 REDIS_HASH REDIS_ENCODING_HT 使用字典实现的哈希对象 REDIS_SET REDIS_ENCODING_INTSET 使用整数集合实现的集合对象 REDIS_SET REDIS_ENCODING_HT 使用字典实现的集合对象 REDIS_ZSET REDIS_ENCODING_ZIPLIST 使用压缩列表实现的有序集合对象 REDIS_ZSET REDIS_ENCODING_SKIPLIST 使用跳跃表和字典实现的有序集合对象 通过OBJECT ENCODING命令可查看一个数据库键的值对象所使用的编码。 通过encoding属性设定对象所使用的编码，而不是为对象关联一种固定的编码，极大地提高了Redis的灵活性，Redis可以根据不同场景为对象设置合适的编码： 因为压缩列表比双端链表更节约内存，且元素较少时，在内存中连续存放的压缩列表可以更快载入缓存 随着列表对象包含的元素越来越多，使用压缩列表的优势消失时，对象的底层实现会转向双端链表。 8.2：字符串对象字符串对象的编码可以是int、raw或embstr。 如果一个字符串对象保存的是整数值，且可以用long类型来表示，那么字符串对象会将整数值保存在ptr属性中（将void*转换成long），并将编码设置为int。 如果字符串对象保存的是字符串值，且长度大于39字节，那么使用SDS来保存该字符串，且编码为raw。 如果字符串对象保存的是字符串值，且长度小于等于39，则使用embstr编码方式来保存。 embstr编码与raw编码一样，都使用redisObject和sdshdr来表示字符串对象。但raw编码会调用两次内存分配函数分别创建redisObject和sdshdr结构，而embstr调用一次内存分配函数来分配一块连续空间，空间依次包含redisObject和sdshdr结构。 embstr编码的内存分配和内存释放都只需要调用一次，且能利用缓存带来的优势。 可以用long double类型表示的浮点数在Redis中也作为字符串值来保存，编码为embstr或raw。 因为长度太大而无法用long表示的整数或无法用long double表示的浮点数用embstr或raw编码。 8.2.1：编码的转换对于int编码的字符串对象，若向该对象执行某些命令（eg:append）使其不再是一个整数值，其编码变为raw。 另外，因为Redis没有为embstr编码的字符串对象编写任何修改程序，所以embstr编码的字符串对象是只读的。当对其进行修改时，程序会将其编码从embstr转换为raw，再进行修改。所以embstr编码的字符串在执行修改命令之后总会变成一个raw编码的字符串对象。 8.2.2：字符串命令的实现 命令 int编码 embstr编码 raw编码 SET 用int编码保存值 用embstr编码保存值 用raw编码保存值 GET 拷贝整数值，转换为字符串值，再向客户端返回 直接返回 直接返回 APPEND 将对象转换为raw编码，再按raw编码方式执行 转换为raw编码再执行 调用sdscatlen函数，将给定字符串追加到末尾 INCRBYFLOAT 取出整数值转换为long double，进行加法，将浮点数结果保存 取出字符串值并尝试将其转换为long double，进行加法，再将浮点数结果保存。若不能转换，向客户端返回错误 同embstr INCRBY 对整数值进行加法，结果作为整数保存 不能执行，返回错误 同embstr DECRBY 对整数值进行减法，结果作为整数保存 不能执行，返回错误 同 STRLEN 拷贝整数转换为字符串，返回字符串长度 调用sdslen，返回长度 同 SETRANGE 转换为raw编码，按raw编码执行 同int编码 将字符串给定索引上的值设置为给定字符 GETRANGE 拷贝整数值转换为字符串，取出给定索引上的字符 直接取出给定索引上的字符 同 8.3：列表对象列表对象的编码可以是ziplist或linkedlist。 8.3.1：编码转换当列表对象同时满足以下两个条件时，使用ziplist编码： 列表对象保存的所有字符串元素的长度都小于64字节； 列表对象保存的元素数量小于512个。不能满足这两个条件的列表对象使用linkedlist编码。 以上两个条件的上限值可以修改，配置文件中list-max-ziplist-value和list-max-ziplist-entries 当使用ziplist编码的列表对象不能满足条件时，会执行对象的编码转换操作，将保存在压缩列表中的所有列表元素转移到双端链表中，编码变为linkedlist。 8.3.2：列表命令的实现 命令 ziplist编码 linkedlist编码 LPUSH 调用ziplistPush，将新元素推入表头 调用listAddNodeHead，将新元素插入表头 RPUSH 调用ziplistPush，将新元素推入表尾 调用listAddNodeTail，将新元素插入表尾 LPOP 调用ziplistIndex定位表头，向用户返回节点保存的元素后调用ziplistDelete删除表头 调用listFirst定位表头，返回节点保存的元素后调用listDelNode删除表头 RPOP 调用ziplistIndex定位表尾，向用户返回节点保存的元素后调用ziplistDelete删除表尾 调用listLast定位表尾，返回节点保存的元素后调用listDelNode删除表尾 LINDEX 调用ziplistIndex定位指定节点，向用户返回节点保存的元素 调用listIndex定位指定节点，向用户返回节点保存的元素 LINSERT 插入新节点到表头或表尾时，使用ziplistPush；其他位置使用ziplistInsert。 调用listInsertNode LREM 遍历压缩列表，调用ziplistDelete删除包含了给定元素的节点 遍历双端链表，调用listDelNode删除包含给定元素的节点 LTRIM 调用ziplistDeleteRange，删除压缩列表中所有不在指定索引范围内的节点 遍历双端链表，调用listDelNode删除链表中所有不在指定索引范围内的节点 LLEN 调用ziplistLen返回压缩列表的长度 调用listLength返回双端链表长度 LSET 先调用ziplistDelete删除指定索引上的节点，再调用ziplistInsert将包含给定元素的新节点插入到相同索引上 调用listIndex定位指定索引上的节点，然后通过赋值操作更新节点值 8.4：哈希对象","categories":[{"name":"笔记","slug":"笔记","permalink":"http://chungen.coding.me/categories/笔记/"},{"name":"后台","slug":"笔记/后台","permalink":"http://chungen.coding.me/categories/笔记/后台/"}],"tags":[{"name":"redis","slug":"redis","permalink":"http://chungen.coding.me/tags/redis/"}]},{"title":"腾讯面试抱佛脚","slug":"腾讯面试抱佛脚","date":"2018-09-24T16:00:00.000Z","updated":"2019-08-28T16:06:19.433Z","comments":true,"path":"2018/09/25/腾讯面试抱佛脚/","link":"","permalink":"http://chungen.coding.me/2018/09/25/腾讯面试抱佛脚/","excerpt":"","text":"1. TCP建立连接为什么是三次握手？在不可靠的信道上进行可靠的数据传输，至少要进行三次握手。如果小于三次，无法保证数据可靠传输；如果大于三次，存在资源浪费。防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误 PS：TCP协议中，主动发起请求的一端称为『客户端』，被动连接的一端称为『服务端』。不管是客户端还是服务端，TCP连接建立完后都能发送和接收数据。 起初，服务器和客户端都为CLOSED状态。在通信开始前，双方都得创建各自的传输控制块（TCB）。服务器创建完TCB后遍进入LISTEN状态，此时准备接收客户端发来的连接请求。 第一次握手客户端向服务端发送连接请求报文段。该报文段的头部中SYN=1，ACK=0，seq=x。请求发送后，客户端便进入SYN-SENT状态。 PS1：SYN=1，ACK=0表示该报文段为连接请求报文。 PS2：x为本次TCP通信的字节流的初始序号。TCP规定：SYN=1的报文段不能有数据部分，但要消耗掉一个序号。 第二次握手服务端收到连接请求报文段后，如果同意连接，则会发送一个应答：SYN=1，ACK=1，seq=y，ack=x+1。该应答发送完成后便进入SYN-RCVD状态。 PS1：SYN=1，ACK=1表示该报文段为连接同意的应答报文。 PS2：seq=y表示服务端作为发送者时，发送字节流的初始序号。 PS3：ack=x+1表示服务端希望下一个数据报发送序号从x+1开始的字节。 第三次握手当客户端收到连接同意的应答后，还要向服务端发送一个确认报文段，表示：服务端发来的连接同意应答已经成功收到。该报文段的头部为：ACK=1，seq=x+1，ack=y+1。客户端发完这个报文段后便进入ESTABLISHED状态，服务端收到这个应答后也进入ESTABLISHED状态，此时连接的建立完成！ 为什么连接建立需要三次握手，而不是两次握手？防止失效的连接请求报文段被服务端接收，从而产生错误。 PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。 若建立连接只需两次握手，客户端并没有太大的变化，仍然需要获得服务端的应答后才进入ESTABLISHED状态，而服务端在收到连接请求后就进入ESTABLISHED状态。此时如果网络拥塞，客户端发送的连接请求迟迟到不了服务端，客户端便超时重发请求。此时，如果那个失效的连接请求抵达了服务端，由于只有两次握手，服务端收到请求就会进入ESTABLISHED状态，等待发送数据或主动发送数据。但此时的客户端并没有进入ESTABLISHED状态，所以服务端将会一直等待下去，这样浪费服务端连接资源。 2. TCP释放连接-四次挥手 TCP连接的释放一共需要四步，因此称为『四次挥手』。我们知道，TCP连接是双向的，因此在四次挥手中，前两次挥手用于断开一个方向的连接，后两次挥手用于断开另一方向的连接。 第一次挥手若A认为数据发送完成，则它需要向B发送连接释放请求。该请求只有报文头，头中携带的主要参数为：FIN=1，seq=u。此时，A将进入FIN-WAIT-1状态。 PS1：FIN=1表示该报文段是一个连接释放请求。 PS2：seq=u，u-1是A向B发送的最后一个字节的序号。 第二次挥手B收到连接释放请求后，会通知相应的应用程序，告诉它A向B这个方向的连接已经释放。此时B进入CLOSE-WAIT状态，并向A发送连接释放的应答，其报文头包含：ACK=1，seq=v，ack=u+1。 PS1：ACK=1：除TCP连接请求报文段以外，TCP通信过程中所有数据报的ACK都为1，表示应答。 PS2：seq=v，v-1是B向A发送的最后一个字节的序号。 PS3：ack=u+1表示希望收到从第u+1个字节开始的报文段，并且已经成功接收了前u个字节。 A收到该应答，进入FIN-WAIT-2状态，等待B发送连接释放请求。 第二次挥手完成后，A到B方向的连接已经释放，B不会再接收数据，A也不会再发送数据。但B到A方向的连接仍然存在，B可以继续向A发送数据。 第三次挥手当B向A发完所有数据后，向A发送连接释放请求，请求头：FIN=1，ACK=1，seq=w，ack=u+1。B便进入LAST-ACK状态。 第四次挥手A收到释放请求后，向B发送确认应答，此时A进入TIME-WAIT状态。该状态会持续2MSL时间，若该时间段内没有B的重发请求的话，就进入CLOSED状态，撤销TCB。当B收到确认应答后，也便进入CLOSED状态，撤销TCB。 为什么A要先进入TIME-WAIT状态，等待2MSL时间后才进入CLOSED状态？为了保证B能收到A的确认应答。若A发完确认应答后直接进入CLOSED状态，那么如果该应答丢失，B等待超时后就会重新发送连接释放请求，但此时A已经关闭了，不会作出任何响应，因此B永远无法正常关闭。 3. 反转链表12345678910111213141516ActList* ReverseList3(ActList* list)&#123; if(NULL==list) return list; ActList* head; head-&gt;next=list; ActList* p=list; ActList* q; while(p-&gt;next!=NULL)&#123; q=p-&gt;next; p-&gt;next=q-&gt;next; q-&gt;next=head-&gt;next; head-&gt;next=q; &#125; return head-&gt;next;&#125; 4. 虚函数的实现4.1. 虚函数表https://jocent.me/2017/08/07/virtual-table.html 一旦发现一个类型中有虚函数，就会为该类型生成一个虚函数表，并在该类型的每一个实例中添加一个指向该虚函数表的指针。 4.2. 单继承下的虚函数表派生类未覆盖基类虚函数虚函数表中依照声明顺序先放基类的虚函数地址，再放派生类的虚函数地址。 派生类覆盖基类虚函数虚表中派生类覆盖基类虚函数的地址被放在基类相应函数原来的位置，派生类中不覆盖的虚函数延用基类的 4.3. 多继承下的虚函数表无虚函数覆盖 有几个基类就有几个虚函数表 派生类的虚函数地址依照声明顺序放在第一个基类的虚表最后 有虚函数覆盖 有几个基类就有几个虚函数表 派生类的虚函数地址依照声明顺序放在第一个基类的虚表最后 若有覆盖，则放在被覆盖的基类虚函数对应位置 5. 虚析构 虚析构函数是为了解决这样的一个问题：基类的指针指向派生类对象，并用基类的指针删除派生类对象。 将一个函数定义为纯虚函数，实际上是将这个类定义为抽象类。简单方法：在想要成为抽象类的类里声明一个纯虚析构函数。 6. TCP滑动窗口协议 数据传输可靠性：保证数据到达目的地，否则超时重传。 数据流控制：管理发送速率，避免过载。 TCP将独立的字节数据当作流来处理。将数据流划分为片段，片段内所有字节都是一起发送和确认的。确认机制使用片段内最后一个字节的序列号。 6.1. TCP数据流划分 1、已发送已确认 2、已发送未确认 3、未发送但接收方准备好 4、未发送且接收方未准备好 6.2. 发送窗口与确认窗口 整个过程关键的操作在于接收方允许发送方一次能容纳的未确认的字节数（2+3）：发送窗口 可用窗口的定义是：考虑到正在传输的数据量，发送方仍被允许发送的数据量（3）。 6.3. 确认处理以及窗口缩放 目标设备会发送自上一次成功接收后的最长字节数来确认接收到的数据流。（TCP的确认机制是累计的） 收到确认信息，发送窗口右移，产生新的可用窗口。 6.4. 处理丢失确认信息 假设已发送未确认字节（32至45）分为4段传输：32-34，35-36，37-41，42-45。第1，2，4已经到达，而3段没有收到。接收方只会发回32-36的确认信息，接收方会保留42-45但不会确认。 在接收到第3段（37-41）之前，接收设备不会发送确认信息，也不会发送这一段之后字节的确认信息。发送设备可以将新的字节添加到第3类之后，即46-50。发送设备之后会停止发送，窗口停留在37-50。 TCP包括一个传输及重传的计时机制。TCP会重传丢失的片段。但有一个缺陷是：因为它不会对每一个片段分别进行确认，这可能会导致其他实际上已经接收到的片段被重传（比如42至45）。 7. TCP拥塞控制 拥塞窗口 7.1. 慢开始与拥塞避免发送的最初执行慢开始，令 cwnd = 1，每次收到确认后，将 cwnd 加倍，设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。 7.2. 快重传与快恢复在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。 8. CPP基础知识8.1. new 与 malloc malloc的全称是memory allocation，中文叫动态内存分配。 malloc()之后必须有一个free()与之对应。 C++中，用new和delete动态创建和释放数组或单个对象。 malloc和new的区别 new 返回指定类型的指针，并且可以自动计算所需要大小。而malloc则必须要由我们计算字节数，并且在返回后强行转换为实际类型的指针。 malloc 只管分配内存，并不能对所得的内存进行初始化，所以得到的一片新内存中，其值将是随机的。new创建的对象可以用初始化变量的方式初始化。 示例 1234567891011int* p = new int(10); //返回类型为int*类型，分配大小为 sizeof(int); double *pd=(double*) malloc (sizeof(double)*12);//分配12个double型存储单元，并将首地址存储到指针变量pd中delete pi ;// 释放单个对象delete []pi;//释放数组free(pd);//释放malloc开辟的空间pd=NULL; 8.2. 栈与堆 栈由编译器自动分配释放，存放函数的参数值、局部变量的值等。 堆一般由程序员分配释放，若不释放，程序结束时可能由操作系统回收。注意这里说是可能，并非一定。所以堆一定要释放！ 9. 并查集 MakeSet Union：秩，保证小的树成为大树的子树。秩相同则合并后的树秩加一。 Find：路径压缩，Find递归地经过树，改变每一个节点的引用到根节点。 1234function Find(x) if x.parent != x x.parent := Find(x.parent) return x.parent 应用：判断图是否连通","categories":[{"name":"笔记","slug":"笔记","permalink":"http://chungen.coding.me/categories/笔记/"},{"name":"后台","slug":"笔记/后台","permalink":"http://chungen.coding.me/categories/笔记/后台/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"http://chungen.coding.me/tags/CPP/"},{"name":"网络","slug":"网络","permalink":"http://chungen.coding.me/tags/网络/"}]},{"title":"Markdown教程","slug":"Markdown教程","date":"2018-08-12T16:00:00.000Z","updated":"2019-08-24T15:07:45.348Z","comments":true,"path":"2018/08/13/Markdown教程/","link":"","permalink":"http://chungen.coding.me/2018/08/13/Markdown教程/","excerpt":"","text":"下标：_ 上标：^ $E=mc^2$ $H$ 斜体 代码块12 s 公式$ \\alpha_\\beta = \\gamma_\\delta $ $\\alpha \\in A$ \\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}$H_2O$ \\begin{align} \\nonumber \\sqrt{37} &= \\sqrt{\\frac{73^2-1}{12^2}} \\\\ \\nonumber &= \\sqrt{\\frac{73^2}{12^2}\\cdot\\frac{73^2-1}{73^2}} \\\\ \\nonumber &= \\sqrt{\\frac{73^2}{12^2}}\\sqrt{\\frac{73^2-1}{73^2}} \\\\ \\nonumber &= \\frac{73}{12}\\sqrt{1 - \\frac{1}{73^2}} \\\\ \\nonumber &\\approx \\frac{73}{12}\\left(1 - \\frac{1}{2\\cdot73^2}\\right) \\end{align} \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\ \\frac{\\partial X}{\\partial u} & \\frac{\\partial Y}{\\partial u} & 0 \\\\ \\frac{\\partial X}{\\partial v} & \\frac{\\partial Y}{\\partial v} & 0 \\\\ \\end{vmatrix} f(X,Y) = \\sum_{i} \\sum_{j} x_iy_j设$f(x,y) = Ke^{-(ax^2+2bxy+cy^2)}$，其中 $a&gt;0,c&gt;0,b^2-ac&lt;0$。如果$f$是密度函数，那么$K=___$。 流程图123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good,thanks! 123456graph LRA[Hard edge] --&gt; B[Round edge]B --&gt; C&#123;Decision&#125;C --&gt; |One| D[Result One]C --&gt; |Two| E[Result Two]C --&gt; F[Result Three] st=>start: Start op=>operation: Your Operation cond=>condition: Yes or No? e=>end st->op->cond cond(yes)->e cond(no)->op{\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"教程","slug":"教程","permalink":"http://chungen.coding.me/categories/教程/"},{"name":"Markdown","slug":"教程/Markdown","permalink":"http://chungen.coding.me/categories/教程/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://chungen.coding.me/tags/Markdown/"}]},{"title":"链接指示：extern \"C\"","slug":"链接指示extern","date":"2018-05-05T16:00:00.000Z","updated":"2019-08-26T03:35:07.305Z","comments":true,"path":"2018/05/06/链接指示extern/","link":"","permalink":"http://chungen.coding.me/2018/05/06/链接指示extern/","excerpt":"","text":"在C++程序中调用其他语言编写的函数，例如C语言。要求有权访问该语言的编译器，并且该编译器与当前C++编译器兼容。 声明非C++函数 两种形式：单语句、复合语句。 链接指示不能出现在类定义或函数定义内部。 非C++函数的每个声明中都必须具有相同的链接指示。 12345678// 单语句链接指示extern \"C\" size_t strlen(const char *);// 复合语句链接指示extern \"C\" &#123; int strcmp(const char *, const char *); char *strcat(char *, const char *);&#125; 链接指示与头文件 采用复合声明的形式。 123extern \"C\" &#123; #include &lt;string.h&gt;&#125; 头文件中的所有普通函数声明都被认为是由链接指示的语言编写的。 链接指示可以嵌套，如果头文件包含自带链接指示的函数，那么该函数的链接不受影响。 导出C++函数到其他语言 通过使用链接指示对函数进行定义： 1extern \"C\" double calc(double dparm) &#123; /* ... */ &#125; 指向 extern “C” 函数的指针 编写函数所用的语言是函数类型的一部分。因此，对于使用链接指示定义的函数而言，它的每个声明中都必须具有相同的链接指示。并且，指向函数的指针必须与函数本身使用相同的链接指示。 123void (*pf1) (int); // 指向一个C++函数extern \"C\" void (*pf2) (int); // 指向一个C函数pf1 = pf2; // 错误：pf1与pf2的类型不同 链接指示不仅对函数有效，而且对作为返回类型或形参类型的函数指针也有效。 123456// f是一个C函数，参数是一个指向C函数的指针// 调用f时，必须传入一个C函数的名字或者指向C函数的指针。extern \"C\" void f(void (*) (int));// 函数名代表某个函数的入口地址（常量）// 函数指针相当于变量，可以存放所有该类型函数的入口地址 因为链接指示同时作用于声明语句中的所有函数（指针），所以如果要给C++函数传入一个指向C函数的指针，则必须使用类型别名。 1234// FC为函数指针类型，指向一个C函数extern \"C\" typedef void (*FC)(int);// f2是一个C++函数，形参为一个指向C函数的指针void f2(FC); 链接指示与重载函数 链接指示与重载函数的相互作用依赖于目标语言。 C语言不支持重载，故一个C链接指示只能用于说明一组重载函数中的一个。 123// 错误：两个 extern \"C\" 函数名相同extern \"C\" void print(const char *);extern \"C\" void print(int); 如果一组重载函数中有一个是C函数（可在C或C++中被调用），则其余的都必须为C++函数（只能在C++中被调用）","categories":[{"name":"笔记","slug":"笔记","permalink":"http://chungen.coding.me/categories/笔记/"},{"name":"CPP","slug":"笔记/CPP","permalink":"http://chungen.coding.me/categories/笔记/CPP/"}],"tags":[{"name":"CPP","slug":"CPP","permalink":"http://chungen.coding.me/tags/CPP/"}]},{"title":"Hexo Tutorial","slug":"HexoTutorial","date":"2018-03-12T16:00:00.000Z","updated":"2019-08-24T10:36:18.054Z","comments":true,"path":"2018/03/13/HexoTutorial/","link":"","permalink":"http://chungen.coding.me/2018/03/13/HexoTutorial/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"教程","slug":"教程","permalink":"http://chungen.coding.me/categories/教程/"},{"name":"博客","slug":"教程/博客","permalink":"http://chungen.coding.me/categories/教程/博客/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://chungen.coding.me/tags/博客/"}]},{"title":"Ubuntu(DigitOcean)+Nginx+Hexo搭建博客","slug":"Ubuntu(DigitOcean)+Nginx+Hexo搭建博客","date":"2018-03-11T16:00:00.000Z","updated":"2019-08-24T10:36:53.589Z","comments":true,"path":"2018/03/12/Ubuntu(DigitOcean)+Nginx+Hexo搭建博客/","link":"","permalink":"http://chungen.coding.me/2018/03/12/Ubuntu(DigitOcean)+Nginx+Hexo搭建博客/","excerpt":"","text":"前几日，由于想自己搭建一个可以翻墙的服务器，便在DigitOcean上买了一个每个月5美元的最低配置版的装有Ubuntu系统的Droplets。如果是学生的话可以在github领学生包，里面有50美元的代金券，直接在github上搜索github student pack就能找到，代金券可以在DigitOcean上面使用。还有一种方法就是通过我的邀请链接在DigitOcean上面注册成功后就可以获得10美元，相当于可以免费用两个月。不过，在注册成功前，你必须先充值5美元以激活帐户，这5美元貌似可以申请退还，不过我没试过，毕竟自己会经常用服务器。 迅速搭建完成后，测试了一下，果然可以科学上网了。于是，又想搞点新鲜的玩意儿，毕竟服务器只用来翻墙貌似有点太浪费。于是就想着搭建一个自己的博客系统，闲来无事可以自己写写随笔，作作技术笔记，也算积累一下经验。 听室友说，Hexo用来搭建博客系统不错，于是便决定用它了。Hexo生成的是静态文件，所以可以在本地利用Hexo先生成静态文件，然后将这些静态文件通过git部署到服务器上，用Nginx做Web服务。由于hexo支持git的部署方式，所以可以实现从本地更新博客，非常方便。 搭建过程本机操作由于本机是windows，所以这里以windows为例。 安装Node.js和Git 生成SSH密钥(有就不用生成)： 1ssh-keygen -t rsa -C \"email@example.com\" # 一路回车 创建一个文件夹作为博客网站的目录（例如：E:\\BLOG） 进入BLOG目录，执行如下命令初始化Hexo博客： 123npm install -g hexo-clihexo initnpm install 安装插件 12npm install hexo-deployer-git --savenpm install hero-server 生成静态文件并启动hexo服务 12hexo ghexo s 打开浏览器输入http://localhost:4000 ，可看到第一篇博客，这只是本地博客。 服务器操作 连接服务器：这里我用git bash连接 1ssh root@&lt;ip地址&gt; 在服务器上安装Git和Node.js以及Nginx 1234sudo apt install gitsudo apt install nodejssudo apt install npmsudo apt install nginx 配置Nginx托管目录 3.1. 创建/var/www/hexo目录，用于Nginx托管 123mkdir -p /var/www/hexochown -R $USER:$USER /var/www/hexochmod -R 755 /var/www/hexo 3.2. 修改Nginx配置 123sudo vi /etc/nginx/sites-enabled/default# 将 root /var/www/html 改为 root /var/www/hexo# 保存退出 3.3. 重启nginx 1nginx -s reload 创建私有git仓库 4.1. 创建用户：git，用于运行git服务 1sudo adduser git 4.2. 将本机的SSH公钥：.ssh目录下的id_rsa.pub内容添加到/home/git/.ssh/authorized_keys文件中。 4.3. 在/home/git下创建一个名为hexo.git的裸仓库 1git init --bare hexo.git 4.4. 创建Git钩子，在满足条件情况下将静态文件传送到Web服务器目录，即/var/www/hexo 1sudo vi /home/git/hexo.git/hooks/post-receive 4.5. 添加如下代码 12#!/bin/bashgit --work-tree=/var/www/hexo --git-dir=/home/git/hexo.git checkout -f 4.6. 保存并退出，将该文件变为可执行文件 1sudo chmod +x /home/git/hexo.git/hooks/post-receive 4.7. 将hexo.git目录和网站目录的所有者改为git用户 12sudo chown -R git:git /home/git/hexo.gitsudo chown -R git:git /var/www/hexo 至此，结束服务器端配置。 部署到服务端 在本机中修改hexo站点配置文件_config.yml 1234deploy:type: gitrepo: git@&lt;服务器IP地址或域名&gt;:/home/git/hexo.gitbranch: master 之后就能通过以下命令，完成博客的更新了。 1hexo d -g 引用： [1] https://www.zxavier.com/Ubuntu+hexo+nginx%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2.html [2] https://tiktoking.github.io/2016/01/26/hexo/","categories":[{"name":"教程","slug":"教程","permalink":"http://chungen.coding.me/categories/教程/"},{"name":"博客","slug":"教程/博客","permalink":"http://chungen.coding.me/categories/教程/博客/"}],"tags":[{"name":"博客","slug":"博客","permalink":"http://chungen.coding.me/tags/博客/"}]}]}